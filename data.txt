[Тема: ООП]
1. Что такое класс и объект?
Ответ: Класс — это шаблон или чертёж, который описывает данные (поля) и поведение (методы) объектов. Например, класс "Машина" определяет, что у машины есть цвет и она может ехать. Объект — это конкретный экземпляр класса, например, красный "Форд", созданный на основе класса "Машина". Один класс может создавать много разных объектов.

2. Что такое статический и нестатический контекст класса?
Ответ: Статический контекст — это элементы (поля, методы), которые принадлежат самому классу, а не объекту. Они существуют в единственном экземпляре и доступны без создания объекта, например, статическое поле count в классе "Машина" хранит общее количество машин. Нестатический контекст — это элементы, связанные с конкретным объектом, например, цвет машины, который уникален для каждого объекта.

3. Что такое члены класса?
Ответ: Члены класса — это все элементы, описанные внутри класса: поля (переменные), методы (функции), конструкторы, блоки инициализации и другие компоненты, которые определяют структуру и поведение класса.

4. Что такое поля, методы, конструкторы и блоки инициализации?
Ответ: Поля — это переменные, хранящие данные объекта или класса (статические или нестатические). Методы — это функции, определяющие поведение объекта или класса, например, метод drive() для машины. Конструкторы — специальные методы, вызываемые при создании объекта для инициализации его полей; если конструктор не указан, используется пустой по умолчанию. Блоки инициализации — код в фигурных скобках, выполняемый при создании объекта (нестатический блок) или загрузке класса (статический блок) для инициализации данных.

5. Что означают ключевые слова abstract и final?
Ответ: abstract — указывает, что класс или метод — это шаблон, который нельзя использовать напрямую. Абстрактный класс нельзя инстанцировать, а абстрактный метод должен быть реализован в дочерних классах. final — означает, что элемент нельзя изменить: final класс нельзя наследовать, final метод нельзя переопределить, final поле нельзя изменить после инициализации (как константа).

6. Каковы основополагающие принципы ООП?
Ответ: Основополагающие принципы ООП: 
- Инкапсуляция: объединение данных и методов, работающих с ними, с ограничением доступа к данным.
- Наследование: позволяет дочернему классу перенимать свойства и методы родительского для повторного использования кода.
- Полиморфизм: способность метода работать по-разному в зависимости от типа объекта.
- Абстракция: выделение только важных характеристик объекта, игнорируя ненужные детали.

7. Что такое инкапсуляция и как она реализуется?
Ответ: Инкапсуляция — это принцип ООП, который скрывает данные и внутреннюю работу объекта, предоставляя доступ только к необходимому через публичные методы. Реализуется с помощью:
- Модификаторов доступа (public, private, protected, default), которые определяют видимость полей и методов.
- Геттеров и сеттеров — методов для безопасного чтения и изменения данных.
- Приватных полей, которые недоступны снаружи объекта, защищая их от случайных изменений.

8. Что такое модификаторы доступа?
Ответ: Модификаторы доступа определяют уровень доступа к полям, методам или классам:
- public: доступно всем.
- private: доступно только внутри класса.
- protected: доступно в классе и его наследниках.
- default (package-private): доступно внутри одного пакета, если модификатор не указан.

9. Что такое наследование и как им управлять?
Ответ: Наследование — это механизм ООП, позволяющий дочернему классу перенимать свойства и методы родительского, добавляя свои особенности. Управление наследованием:
- Модификаторы доступа (public, protected, private) задают, что наследуется.
- Ключевое слово final запрещает наследование класса или переопределение метода.
- Абстрактные классы и методы задают шаблоны для реализации в дочерних классах.
- Переопределение методов позволяет менять поведение родителя.
- Интерфейсы задают обязательные методы без наследования.
- Ключевое слово super вызывает родительскую логику.

10. Что такое полиморфизм и как он реализуется?
Ответ: Полиморфизм — это способность метода работать по-разному в зависимости от типа объекта. Реализуется через:
- Переопределение методов (override): дочерний класс изменяет реализацию метода родителя.
- Интерфейсы: задают методы, которые классы реализуют по-своему.
- Абстрактные классы: содержат методы без реализации, уточняемые в дочерних классах.
- Перегрузка методов (overload): методы с одинаковым именем, но разными параметрами.
- Приведение типов: использование объекта дочернего класса как родительского.

11. Чем отличается абстрактный класс от интерфейса?
Ответ: Абстрактный класс — это шаблон, который может содержать поля, методы с реализацией и абстрактные методы, но нельзя создать его объект. Интерфейс — это контракт, задающий только методы (без реализации или с реализацией по умолчанию в современных языках) и константы. Класс может наследовать один абстрактный класс, но реализовать несколько интерфейсов. Абстрактный класс подходит для общей основы с частичной реализацией, интерфейс — для строгого набора функций.

12. Что такое интерфейсы, их определение, реализация и наследование?
Ответ: Интерфейс — это контракт, задающий методы, которые класс должен реализовать, без указания их кода. Реализация — это когда класс "подписывается" на интерфейс и определяет его методы. Наследование интерфейсов: один интерфейс может наследовать другой, требуя реализации методов обоих. Класс может реализовать несколько интерфейсов, что обеспечивает гибкость, в отличие от одиночного наследования классов.

13. Что такое дженерики, их определение, реализация и примеры?
Ответ: Дженерики — это механизм, позволяющий создавать классы, интерфейсы или методы, работающие с разными типами данных с сохранением строгой типизации. Реализуются через параметры типа (например, T), которые заменяются конкретным типом при использовании. Примеры:
- Обобщённый класс-контейнер для хранения данных любого типа (например, строк).
- Список, принимающий только определённый тип (List<String>).
- Обобщённый метод сортировки, работающий с числами или строками, если они поддерживают сравнение.

14. Что такое интерфейсы Comparator и Comparable, их описание, различия и примеры использования?
Ответ: Comparable — интерфейс, задающий естественный порядок сортировки внутри класса через метод compareTo(). Comparator — интерфейс для внешнего определения порядка сортировки через метод compare(). 
- Различия: Comparable реализуется в классе и задаёт один порядок; Comparator создаётся отдельно и позволяет множественные правила сортировки.
- Примеры: Comparable — сортировка книг по году издания; Comparator — сортировка тех же книг по названию или автору без изменения класса.

15. Что такое коллекции типа List, их описание, представители, механизм работы и различия реализаций?
Ответ: List — интерфейс для упорядоченной коллекции с индексами, сохраняющий порядок добавления и допускающий дубликаты. Представители:
- ArrayList: динамический массив, быстрый доступ по индексу, медленные вставки/удаления в середину.
- LinkedList: двусвязный список, быстрые вставки/удаления, медленный доступ по индексу.
- Vector: устаревший, синхронизированный ArrayList.
- CopyOnWriteArrayList: для многопоточных приложений с редкими изменениями.
Механизм: задаёт методы для добавления, удаления, доступа по индексу; реализации используют разные структуры данных.

16. Что такое коллекции типа Map, их описание, представители, механизм работы и различия реализаций?
Ответ: Map — интерфейс для хранения пар "ключ-значение" с уникальными ключами. Представители:
- HashMap: хэш-таблица, быстрый поиск, не сохраняет порядок.
- TreeMap: красно-чёрное дерево, сортирует ключи, медленнее HashMap.
- LinkedHashMap: хэш-таблица с сохранением порядка добавления.
- ConcurrentHashMap: потокобезопасная версия HashMap.
Механизм: задаёт методы для добавления, поиска, удаления по ключу; реализации используют разные структуры данных.

[Тема: ООП-Практика]
17. Опишите класс «поезд» и класс «вокзал», их функциональность и программу, демонстрирующую их работу.
Ответ: Класс «Поезд» содержит закрытые поля: название пункта назначения, номер поезда, время отправления. Предусмотрены геттеры и метод compareTo для сравнения по времени. Класс «Вокзал» содержит массив поездов (List<Train>) и методы:
- Поиск поезда по номеру или индексу.
- Вывод поездов, отправляющихся после заданного времени.
- Вывод поездов в заданный пункт назначения, отсортированных по времени.
Программа демонстрирует добавление поездов, поиск по номеру/индексу, фильтрацию по времени и пункту назначения, используя ввод с клавиатуры.
Код:
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

// Класс Поезд
class Train implements Comparable<Train> {
    private String destination;
    private String trainNumber;
    private LocalTime departureTime;

    public Train(String destination, String trainNumber, LocalTime departureTime) {
        this.destination = destination;
        this.trainNumber = trainNumber;
        this.departureTime = departureTime;
    }

    public String getDestination() {
        return destination;
    }

    public String getTrainNumber() {
        return trainNumber;
    }

    public LocalTime getDepartureTime() {
        return departureTime;
    }

    @Override
    public String toString() {
        return "Поезд №" + trainNumber + ", Пункт назначения: " + destination +
               ", Время отправления: " + departureTime.format(DateTimeFormatter.ofPattern("HH:mm"));
    }

    @Override
    public int compareTo(Train other) {
        return this.departureTime.compareTo(other.departureTime);
    }
}

// Класс Вокзал
class Station {
    private List<Train> trains;

    public Station() {
        trains = new ArrayList<>();
    }

    public void addTrain(Train train) {
        trains.add(train);
    }

    public Train getTrainByNumber(String trainNumber) {
        for (Train train : trains) {
            if (train.getTrainNumber().equalsIgnoreCase(trainNumber)) {
                return train;
            }
        }
        return null;
    }

    public Train getTrainByIndex(int index) {
        if (index >= 0 && index < trains.size()) {
            return trains.get(index);
        }
        return null;
    }

    public void printTrainsAfterTime(LocalTime time) {
        System.out.println("Поезда, отправляющиеся после " + time.format(DateTimeFormatter.ofPattern("HH:mm")) + ":");
        for (Train train : trains) {
            if (train.getDepartureTime().isAfter(time)) {
                System.out.println(train);
            }
        }
    }

    public void printTrainsToDestination(String destination) {
        System.out.println("Поезда в " + destination + ", отсортированные по времени отправления:");
        List<Train> filteredTrains = new ArrayList<>();
        for (Train train : trains) {
            if (train.getDestination().equalsIgnoreCase(destination)) {
                filteredTrains.add(train);
            }
        }
        filteredTrains.sort(Comparator.naturalOrder());
        for (Train train : filteredTrains) {
            System.out.println(train);
        }
    }

    public void printAllTrains() {
        System.out.println("Количество поездов: " + trains.size());
        if (trains.isEmpty()) {
            System.out.println("Нет поездов.");
        } else {
            System.out.println("Список поездов:");
            for (Train train : trains) {
                System.out.println(train);
            }
        }
    }

    public int getTrainCount() {
        return trains.size();
    }
}

// Главный класс
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Station station = new Station();

        // Поезда по умолчанию
        station.addTrain(new Train("Москва", "T123", LocalTime.of(10, 30)));
        station.addTrain(new Train("Санкт-Петербург", "A456", LocalTime.of(12, 15)));
        station.addTrain(new Train("Москва", "B789", LocalTime.of(9, 45)));

        // Вывод текущего времени и информации о поездах
        System.out.println("Текущее время: " + LocalTime.now().format(DateTimeFormatter.ofPattern("HH:mm")));
        station.printAllTrains();

        // Демонстрация поиска по индексу
        System.out.print("\nВведите индекс поезда (0-" + (station.getTrainCount() > 0 ? station.getTrainCount() - 1 : 0) + "): ");
        int index = Integer.parseInt(scanner.nextLine());
        Train trainByIndex = station.getTrainByIndex(index);
        if (trainByIndex != null) {
            System.out.println("Поезд по индексу " + index + ": " + trainByIndex);
        } else {
            System.out.println("Поезд с индексом " + index + " не найден.");
        }

        // Ввод новых поездов
        System.out.print("\nВведите количество новых поездов: ");
        int trainCount = Integer.parseInt(scanner.nextLine());

        for (int i = 0; i < trainCount; i++) {
            System.out.println("Поезд " + (i + 1) + ":");
            System.out.print("Пункт назначения: ");
            String destination = scanner.nextLine();
            System.out.print("Номер поезда: ");
            String trainNumber = scanner.nextLine();
            System.out.print("Время отправления (чч:мм): ");
            String timeInput = scanner.nextLine();
            LocalTime departureTime = LocalTime.parse(timeInput, DateTimeFormatter.ofPattern("HH:mm"));
            station.addTrain(new Train(destination, trainNumber, departureTime));
        }

        // Поиск по номеру
        System.out.print("\nВведите номер поезда для поиска: ");
        String trainNumber = scanner.nextLine();
        Train train = station.getTrainByNumber(trainNumber);
        if (train != null) {
            System.out.println("Найден поезд: " + train);
        } else {
            System.out.println("Поезд с номером " + trainNumber + " не найден.");
        }

        // Поезда после времени
        System.out.print("\nВведите время (чч:мм) для фильтрации: ");
        String timeInput = scanner.nextLine();
        LocalTime time = LocalTime.parse(timeInput, DateTimeFormatter.ofPattern("HH:mm"));
        station.printTrainsAfterTime(time);

        // Поезда в пункт назначения
        System.out.print("\nВведите пункт назначения: ");
        String destination = scanner.nextLine();
        station.printTrainsToDestination(destination);

        scanner.close();
    }
}

18. Опишите класс «товар» и класс «склад», их функциональность и программу, демонстрирующую их работу.
Ответ: Класс «Товар» содержит закрытые поля: название товара, название магазина, цена. Предусмотрены геттеры, метод сложения цен и compareTo для сортировки по названию. Класс «Склад» содержит массив товаров (List<Product>) и методы:
- Поиск товара по индексу или названию.
- Сортировка товаров по названию, магазину или цене.
- Вывод всех товаров или сообщение, если товар не найден.
Программа демонстрирует добавление товаров, поиск по индексу/названию, сортировку по разным критериям и сложение цен, используя ввод с клавиатуры.
Код:
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

// Класс Товар
class Product implements Comparable<Product> {
    private String name;
    private String shop;
    private double price;

    public Product(String name, String shop, double price) {
        this.name = name;
        this.shop = shop;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public String getShop() {
        return shop;
    }

    public double getPrice() {
        return price;
    }

    public double addPrice(Product other) {
        return this.price + other.price;
    }

    @Override
    public String toString() {
        return "Товар: " + name + ", Магазин: " + shop + ", Цена: " + price + " руб.";
    }

    @Override
    public int compareTo(Product other) {
        return this.name.compareToIgnoreCase(other.name);
    }
}

// Класс Склад
class Warehouse {
    private List<Product> products;

    public Warehouse() {
        products = new ArrayList<>();
    }

    public void addProduct(Product product) {
        products.add(product);
    }

    public Product getProductByIndex(int index) {
        if (index >= 0 && index < products.size()) {
            return products.get(index);
        }
        return null;
    }

    public void printProductByName(String name) {
        boolean found = false;
        for (Product product : products) {
            if (product.getName().equalsIgnoreCase(name)) {
                System.out.println(product);
                found = true;
            }
        }
        if (!found) {
            System.out.println("Товар с названием \"" + name + "\" не найден.");
        }
    }

    public void printProductsSortedByShop() {
        System.out.println("Товары, отсортированные по магазину:");
        List<Product> sorted = new ArrayList<>(products);
        sorted.sort(Comparator.comparing(Product::getShop, String.CASE_INSENSITIVE_ORDER));
        for (Product product : sorted) {
            System.out.println(product);
        }
    }

    public void printProductsSortedByName() {
        System.out.println("Товары, отсортированные по названию:");
        List<Product> sorted = new ArrayList<>(products);
        sorted.sort(Comparator.naturalOrder());
        for (Product product : sorted) {
            System.out.println(product);
        }
    }

    public void printProductsSortedByPrice() {
        System.out.println("Товары, отсортированные по цене:");
        List<Product> sorted = new ArrayList<>(products);
        sorted.sort(Comparator.comparingDouble(Product::getPrice));
        for (Product product : sorted) {
            System.out.println(product);
        }
    }

    public void printAllProducts() {
        System.out.println("Количество товаров: " + products.size());
        if (products.isEmpty()) {
            System.out.println("Нет товаров.");
        } else {
            System.out.println("Список товаров:");
            for (Product product : products) {
                System.out.println(product);
            }
        }
    }

    public int getProductCount() {
        return products.size();
    }
}

// Демонстрационная программа
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Warehouse warehouse = new Warehouse();

        warehouse.addProduct(new Product("Телефон", "Магазин А", 30000));
        warehouse.addProduct(new Product("Ноутбук", "Магазин Б", 75000));
        warehouse.addProduct(new Product("Планшет", "Магазин А", 25000));

        System.out.println("Текущее время: " + java.time.LocalTime.now().format(java.time.format.DateTimeFormatter.ofPattern("HH:mm")));
        warehouse.printAllProducts();

        Product product1 = warehouse.getProductByIndex(0);
        Product product2 = warehouse.getProductByIndex(1);
        if (product1 != null && product2 != null) {
            System.out.println("\nСумма цен " + product1.getName() + " и " + product2.getName() + ": " +
                               product1.addPrice(product2) + " руб.");
        }

        System.out.print("\nВведите индекс товара (0-" + (warehouse.getProductCount() > 0 ? warehouse.getProductCount() - 1 : 0) + "): ");
        int index = Integer.parseInt(scanner.nextLine());
        Product productByIndex = warehouse.getProductByIndex(index);
        if (productByIndex != null) {
            System.out.println("Товар по индексу " + index + ": " + productByIndex);
        } else {
            System.out.println("Товар с индексом " + index + " не найден.");
        }

        System.out.print("\nВведите количество новых товаров: ");
        int productCount = Integer.parseInt(scanner.nextLine());
        for (int i = 0; i < productCount; i++) {
            System.out.println("Товар " + (i + 1) + ":");
            System.out.print("Название: ");
            String name = scanner.nextLine();
            System.out.print("Магазин: ");
            String shop = scanner.nextLine();
            System.out.print("Цена (руб.): ");
            double price = Double.parseDouble(scanner.nextLine());
            warehouse.addProduct(new Product(name, shop, price));
        }

        System.out.print("\nВведите название товара для поиска: ");
        String name = scanner.nextLine();
        warehouse.printProductByName(name);

        warehouse.printProductsSortedByName();
        warehouse.printProductsSortedByShop();
        warehouse.printProductsSortedByPrice();

        scanner.close();
    }
}

[Тема: Базы данных]
1. Зачем нужно проектирование баз данных, каковы его цели и этапы?
Ответ: Необходимость проектирования баз данных заключается в эффективном хранении, обработке и извлечении информации, обеспечении целостности данных и минимизации избыточности.
Цели проектирования:
- Обеспечение хранения всей необходимой информации.
- Возможность получения данных по всем необходимым запросам.
- Сокращение избыточности и дублирования данных.
- Обеспечение целостности базы данных.
Этапы проектирования:
- Концептуальное проектирование: определение сущностей, атрибутов и связей без учета СУБД.
- Логическое проектирование: преобразование концептуальной модели в логическую с учетом модели данных (например, реляционной).
- Физическое проектирование: определение структуры хранения, индексов, методов доступа и физических аспектов реализации.

2. Что такое сущность, атрибут, ключ, запись и связь в реляционной базе данных?
Ответ: 
- Сущность: объект предметной области, информация о котором хранится (например, "Студент").
- Атрибут: свойство или характеристика сущности (например, "Имя", "Фамилия").
- Ключ: атрибут или комбинация атрибутов, однозначно идентифицирующих запись.
- Запись (кортеж): строка в таблице, содержащая значения атрибутов одной сущности.
- Связь: ассоциация между сущностями, отражающая их взаимодействие или зависимость.

3. Какие виды моделей данных существуют? Опишите иерархическую и сетевую модели, их достоинства и недостатки.
Ответ: 
- Иерархическая модель:
  Структура: данные организованы в виде дерева с отношениями "один ко многим".
  Достоинства: быстрый доступ при фиксированной структуре запросов, эффективное использование памяти.
  Недостатки: жесткая структура, сложность изменения схемы, трудности в моделировании сложных взаимосвязей.
- Сетевая модель:
  Структура: данные организованы в виде графа с произвольными связями.
  Достоинства: гибкость в представлении сложных взаимосвязей, высокая производительность.
  Недостатки: сложность проектирования и понимания структуры, зависимость логики доступа от физической организации данных.

4. Что такое реляционная модель данных, её основные понятия и элементы?
Ответ: Реляционная модель данных: данные представлены в виде таблиц (отношений), где строки — записи, а столбцы — атрибуты.
Основные понятия:
- Отношение: таблица с данными о сущностях.
- Атрибут: столбец, представляющий свойство сущности.
- Кортеж: строка, представляющая одну запись.
- Домен: допустимые значения для атрибута.
- Первичный ключ: атрибут или набор атрибутов, уникально идентифицирующий запись.
- Внешний ключ: атрибут, ссылающийся на первичный ключ другой таблицы, реализующий связь.

5. Какие операции реляционной алгебры применяются к базам данных?
Ответ: Реляционная алгебра — формальный язык для работы с реляционными базами данных. Основные операции:
- Выборка (σ): извлекает строки, удовлетворяющие условию.
- Проекция (π): выбирает столбцы, устраняя дубликаты.
- Объединение (∪): объединяет строки двух совместимых отношений.
- Пересечение (∩): возвращает общие строки двух отношений.
- Вычитание (−): возвращает строки, присутствующие в первом отношении, но отсутствующие во втором.
- Декартово произведение (×): создаёт все возможные комбинации строк двух отношений.
- Соединение (⨝): объединяет строки двух отношений по условию.

6. Что такое ключ отношения? Какие виды ключей существуют? Каковы правила выбора ключа?
Ответ: 
Ключ отношения: атрибут или набор атрибутов, уникально идентифицирующих строку.
Виды ключей:
- Первичный ключ: основной уникальный идентификатор строки.
- Суррогатный ключ: искусственный уникальный идентификатор без бизнес-смысла.
- Альтернативные ключи: другие уникальные комбинации атрибутов, кроме первичного ключа.
- Составной ключ: ключ из нескольких атрибутов.
Правила выбора ключа:
- Ключ должен быть минимальным по составу.
- Значения ключа не должны изменяться со временем.
- Предпочтение отдается атрибутам с бизнес-смыслом.

7. Что такое функциональная зависимость атрибутов и какие её виды существуют?
Ответ: 
Функциональная зависимость (ФЗ): отношение, при котором значение одного атрибута однозначно определяет значение другого (X → Y).
Виды ФЗ:
- Полная: атрибут зависит от всего составного ключа.
- Частичная: атрибут зависит от части составного ключа.
- Транзитивная: атрибут зависит от другого атрибута, который зависит от ключа.

8. Что такое нормализация базы данных? Какие нормальные формы существуют? Каковы требования 1НФ, 2НФ и 3НФ?
Ответ: 
Нормализация: процесс организации структуры базы данных для уменьшения избыточности и обеспечения целостности.
Нормальные формы:
- Первая нормальная форма (1НФ): атрибуты атомарны, нет повторяющихся групп.
- Вторая нормальная форма (2НФ): удовлетворяет 1НФ, все неключевые атрибуты полностью зависят от первичного ключа.
- Третья нормальная форма (3НФ): удовлетворяет 2НФ, отсутствуют транзитивные зависимости между неключевыми атрибутами.

9. Что такое связь между сущностями и каковы её характеристики?
Ответ: 
Связь между сущностями — ассоциация, отражающая логическую зависимость между сущностями.
Характеристики:
- Степень связи: количество участвующих сущностей (чаще бинарные).
- Кратность (кардинальность): типы связей — один к одному (1:1), один ко многим (1:N), многие ко многим (M:N).
- Обязательность: определяет, обязательно ли участие сущности в связи.

10. Как привести связь типа «многие ко многим» к типу «один ко многим»?
Ответ: Связь «многие ко многим» в реляционных базах данных реализуется через промежуточную таблицу (таблицу-связку), которая разбивает её на две связи «один ко многим». Например, для сущностей «Студенты» и «Курсы» создаётся таблица «Записи» с внешними ключами на таблицы «Студенты» и «Курсы», где каждая запись связывает одного студента с одним курсом.

11. Что такое СУБД Access, её характеристики, применение и состав базы данных?
Ответ: Microsoft Access — реляционная СУБД из пакета Microsoft Office.
Характеристики:
- Интуитивный интерфейс.
- Поддержка SQL.
- Создание форм, отчетов, макросов.
- Интеграция с Microsoft Office.
Применение:
- Малые и средние предприятия.
- Образовательные учреждения.
- Личное использование.
Состав базы данных:
- Таблицы: хранят данные.
- Запросы: поиск и анализ данных.
- Формы: интерфейс для ввода/отображения.
- Отчеты: форматированный вывод.
- Макросы: автоматизация задач.
- Модули: код на VBA.

12. Что такое предложение SELECT языка SQL и его элементы?
Ответ: Оператор SELECT извлекает данные из базы данных.
Элементы:
- SELECT: определяет столбцы для извлечения.
- FROM: указывает таблицы.
- WHERE: фильтрует строки по условиям.
- GROUP BY: группирует строки по значениям столбцов.
- HAVING: фильтрует группы по условиям.
- ORDER BY: сортирует результаты (ASC/DESC).
Пример:
SELECT имя, COUNT(*) AS количество_заказов
FROM заказы
WHERE статус = 'выполнен'
GROUP BY имя
HAVING COUNT(*) > 5
ORDER BY количество_заказов DESC;

13. Какие виды запросов к базе данных существуют и как они реализуются в SQL?
Ответ: Виды запросов:
- DQL (Data Query Language): SELECT — выборка данных.
- DML (Data Manipulation Language): INSERT, UPDATE, DELETE — изменение данных.
- DDL (Data Definition Language): CREATE, ALTER, DROP — определение структуры.
- DCL (Data Control Language): GRANT, REVOKE — управление доступом.
- TCL (Transaction Control Language): COMMIT, ROLLBACK, SAVEPOINT — управление транзакциями.
Примеры:
-- DQL
SELECT * FROM employees;
-- DML
INSERT INTO employees (name, position) VALUES ('Иванов И.И.', 'менеджер');
-- DDL
CREATE TABLE departments (id INT PRIMARY KEY, name VARCHAR(100));
-- DCL
GRANT SELECT ON employees TO user_name;
-- TCL
BEGIN;
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 2;
COMMIT;

14. Что такое подзапросы в SQL, их назначение, виды и порядок выполнения?
Ответ: Подзапрос — запрос, вложенный в другой SQL-запрос.
Назначение:
- Получение промежуточных результатов.
- Фильтрация данных.
- Выполнение сложных вычислений.
Виды:
- Скалярные: возвращают одно значение.
- Множественные: возвращают множество значений (один столбец).
- Табличные: возвращают таблицу.
- Коррелированные: зависят от внешнего запроса.
- Некоррелированные: независимы от внешнего запроса.
Порядок выполнения: сначала подзапрос, затем основной запрос.

15. Что такое запросы с параметром, их достоинства и недостатки?
Ответ: Параметризованные запросы — SQL-запросы, использующие параметры вместо прямых значений.
Достоинства:
- Безопасность: защита от SQL-инъекций.
- Производительность: повторное использование планов запросов.
- Гибкость: один шаблон для разных значений.
Недостатки:
- Дополнительная обработка параметров.
- Сложность отладки.

16. Что такое целостность и сохранность баз данных, какие виды целостности существуют?
Ответ: Целостность данных — точность, согласованность и достоверность данных.
Виды целостности:
- Сущностная: уникальность записей (первичные ключи).
- Ссылочная: корректность внешних ключей.
- Доменная: соответствие значений типам и ограничениям.
- Пользовательская: бизнес-правила (например, "зарплата > 0").
Сохранность: обеспечивается резервным копированием, контролем доступа, журналированием транзакций.

[Тема: БД-Практика]
17. Разработайте базу данных для предприятия связи, содержащую таблицы «Сотрудники» и «Штатное расписание». Составьте запросы «Зарплата» и «Отделы».
Ответ: База данных для предприятия связи включает таблицы:
- Сотрудники: табельный номер, ФИО, отдел, код должности, пол, дата рождения, стаж, семейное положение (Б, Х, Р), дети.
- Штатное расписание: код должности, должность, оклад.
Связь: внешний ключ position_code в таблице Employees ссылается на position_code в Salary_Schedule.
Запрос «Зарплата»: вычисляет зарплату (оклад + премия, где премия = 50% оклада при стаже ≤ 5 лет, 100% при стаже > 5 лет).
Запрос «Отделы»: выводит количество сотрудников, максимальную/минимальную зарплату, общее количество детей по отделам.
Код:
CREATE TABLE Salary_Schedule (
    position_code INT PRIMARY KEY,
    position_name VARCHAR(50),
    salary DECIMAL(10, 2)
);

CREATE TABLE Employees (
    employee_id INT PRIMARY KEY,
    full_name VARCHAR(100),
    department VARCHAR(50),
    position_code INT,
    gender CHAR(1),
    birth_date DATE,
    experience INT,
    marital_status CHAR(1),
    children_count INT,
    FOREIGN KEY (position_code) REFERENCES Salary_Schedule(position_code)
);

-- Вставка данных в Salary_Schedule
INSERT INTO Salary_Schedule (position_code, position_name, salary) VALUES
(1, 'Менеджер', 60000),
(2, 'Разработчик', 80000),
(3, 'Тестировщик', 50000);

-- Вставка данных в Employees
INSERT INTO Employees (employee_id, full_name, department, position_code, gender, birth_date, experience, marital_status, children_count) VALUES
(1, 'Иванов Иван Иванович', 'Отдел продаж', 1, 'М', '1985-05-15', 6, 'Б', 2),
(2, 'Петрова Мария Сергеевна', 'Отдел разработки', 2, 'Ж', '1990-03-20', 4, 'Х', 0),
(3, 'Сидоров Алексей Николаевич', 'Отдел тестирования', 3, 'М', '1988-11-30', 7, 'Р', 1);

-- Запрос «Зарплата»
SELECT 
    e.full_name,
    s.salary,
    CASE 
        WHEN e.experience <= 5 THEN s.salary * 0.5
        ELSE s.salary
    END AS bonus,
    (s.salary + CASE 
        WHEN e.experience <= 5 THEN s.salary * 0.5
        ELSE s.salary
    END) AS total_salary
FROM 
    Employees e
JOIN 
    Salary_Schedule s ON e.position_code = s.position_code;

-- Запрос «Отделы»
SELECT 
    e.department,
    COUNT(e.employee_id) AS employee_count,
    MAX(s.salary + CASE 
        WHEN e.experience <= 5 THEN s.salary * 0.5
        ELSE s.salary
    END) AS max_salary,
    MIN(s.salary + CASE 
        WHEN e.experience <= 5 THEN s.salary * 0.5
        ELSE s.salary
    END) AS min_salary,
    SUM(e.children_count) AS total_children
FROM 
    Employees e
JOIN 
    Salary_Schedule s ON e.position_code = s.position_code
GROUP BY 
    e.department;

18. Создайте и заполните базу данных сотрудников предприятия связи. Составьте запросы для выборки информации о сотрудниках и по подразделениям.
Ответ: База данных включает таблицы:
- Сотрудники: табельный номер, ФИО, отдел, код должности, пол, дата рождения, стаж, семейное положение (Б, Х, Р), дети.
- Штатное расписание: код должности, должность, оклад.
Связь: внешний ключ position_code в Employees ссылается на position_code в Salary_Schedule.
Запрос о сотрудниках: выводит подразделение, ФИО, зарплату в рублях и долларах (курс 75 рублей), сортировка по ФИО, зарплата = оклад + 80% оклада.
Запрос по подразделениям: средняя зарплата, количество женщин, общее количество детей.
Код:
CREATE DATABASE communication_company;
USE communication_company;

CREATE TABLE Salary_Schedule (
    position_code INT PRIMARY KEY,
    position_name VARCHAR(50),
    salary DECIMAL(10, 2)
);

CREATE TABLE Employees (
    employee_id INT PRIMARY KEY,
    full_name VARCHAR(100),
    department VARCHAR(50),
    position_code INT,
    gender CHAR(1),
    birth_date DATE,
    experience INT,
    marital_status CHAR(1),
    children_count INT,
    FOREIGN KEY (position_code) REFERENCES Salary_Schedule(position_code)
);

-- Вставка данных в Salary_Schedule
INSERT INTO Salary_Schedule (position_code, position_name, salary) VALUES
(1, 'Менеджер', 60000),
(2, 'Разработчик', 80000),
(3, 'Тестировщик', 50000),
(4, 'Аналитик', 70000);

-- Вставка данных в Employees
INSERT INTO Employees (employee_id, full_name, department, position_code, gender, birth_date, experience, marital_status, children_count) VALUES
(1, 'Иванов Иван Иванович', 'Отдел продаж', 1, 'М', '1985-05-15', 6, 'Б', 2),
(2, 'Петрова Мария Сергеевна', 'Отдел разработки', 2, 'Ж', '1990-03-20', 4, 'Х', 0),
(3, 'Сидоров Алексей Николаевич', 'Отдел тестирования', 3, 'М', '1988-11-30', 7, 'Р', 1),
(4, 'Кузнецова Анна Владимировна', 'Отдел аналитики', 4, 'Ж', '1987-08-10', 5, 'Б', 1),
(5, 'Федоров Сергей Николаевич', 'Отдел разработки', 2, 'М', '1992-01-25', 3, 'Х', 0);

-- Запрос о сотрудниках
SELECT 
    e.department,
    e.full_name,
    (s.salary + s.salary * 0.8) AS salary_rub,
    (s.salary + s.salary * 0.8) / 75 AS salary_usd
FROM 
    Employees e
JOIN 
    Salary_Schedule s ON e.position_code = s.position_code
ORDER BY 
    e.full_name;

-- Запрос по подразделениям
SELECT 
    e.department,
    AVG(s.salary + s.salary * 0.8) AS average_salary,
    SUM(CASE WHEN e.gender = 'Ж' THEN 1 ELSE 0 END) AS female_count,
    SUM(e.children_count) AS total_children
FROM 
    Employees e
JOIN 
    Salary_Schedule s ON e.position_code = s.position_code
GROUP BY 
    e.department;

[Тема: Защита информации]
1. Что такое компьютерный вирус, какие его виды, вредоносные функции, пути распространения и проявления действия?
Ответ: Компьютерный вирус — вредоносная программа, способная самовоспроизводиться, внедряясь в другие файлы и программы.
Виды вирусов:
- Файловые: заражают исполняемые файлы (.exe, .com).
- Загрузочные (boot-вирусы): заражают загрузочные сектора дисков.
- Сетевые (черви): распространяются по сети.
- Трояны: маскируются под полезные программы, выполняя вредоносные действия.
- Макровирусы: заражают документы с макросами (например, Word, Excel).
Вредоносные функции:
- Повреждение или удаление данных.
- Нарушение работы ОС.
- Передача данных злоумышленнику.
- Создание «бэкдоров» для удалённого доступа.
Пути распространения:
- Съёмные носители (флешки).
- Электронная почта.
- Скачивание из интернета.
- Уязвимости в ПО.
Проявления:
- Торможение системы.
- Сбои в работе программ.
- Появление лишних файлов, окон, сообщений.
- Потеря данных.

2. Каковы основные понятия безопасности информации?
Ответ: 
- Конфиденциальность: защита информации от несанкционированного доступа.
- Целостность: сохранность информации без изменений, искажения и потерь.
- Доступность: возможность легального доступа к информации в нужное время.

3. Какие виды мер обеспечения информационной безопасности существуют?
Ответ: 
- Законодательные: законы, ГОСТы, нормативные акты (например, закон «О персональных данных»).
- Морально-этические: нормы поведения пользователей, соблюдение ИТ-этики.
- Организационные: контроль доступа, обучение персонала, политика безопасности.
- Технические: установка замков, видеонаблюдение, охрана серверных.
- Программно-математические: антивирусы, брандмауэры, шифрование, контроль доступа.

4. Какие основные защитные механизмы построения систем защиты информации существуют?
Ответ: 
- Идентификация: установление личности пользователя (например, логин).
- Аутентификация: подтверждение личности (например, пароль, смс-код, отпечаток).
- Разграничение доступа: определение, кто и что может делать с информацией (например, роли: админ, пользователь).
- Контроль целостности: проверка, не были ли изменены данные (например, с помощью хеш-функций).

5. Какие криптографические механизмы обеспечивают конфиденциальность, целостность и аутентичность информации? Что такое электронная цифровая подпись?
Ответ: 
- Конфиденциальность: достигается шифрованием (симметричным и асимметричным).
- Целостность: проверяется через контрольные суммы, хеш-функции (например, SHA-256).
- Аутентичность: обеспечивается цифровыми подписями и сертификатами.
Электронная цифровая подпись (ЭЦП): криптографический механизм, подтверждающий, что данные отправлены конкретным лицом и не были изменены.

6. Как классифицируются антивирусные программы? Какие существуют программы-детекторы, доктора, ревизоры, фильтры? Как проводится профилактика заражения вирусом?
Ответ: 
Классификация антивирусных программ:
- Детекторы: находят известные вирусы по сигнатурам.
- Доктора (фаги): удаляют вирусы из заражённых файлов и восстанавливают их.
- Ревизоры: отслеживают изменения в файлах и системных областях.
- Фильтры (мониторы): работают в фоновом режиме, контролируя поведение программ в реальном времени.
Профилактика заражения вирусом:
- Использование обновлённого антивируса.
- Не открывать подозрительные письма и файлы.
- Регулярное обновление ОС и программ.
- Резервное копирование данных.
- Ограничение прав пользователя.

[Тема: Сетевое программирование]
1. Что такое система контроля версий, какие её виды и примеры?
Ответ: Система контроля версий (СКВ) — инструмент для отслеживания изменений в коде, управления версиями файлов и совместной работы.
Виды СКВ:
- Локальные: изменения хранятся локально (например, RCS).
- Централизованные: центральный сервер хранит проект (например, Subversion (SVN), CVS).
- Распределённые: каждый разработчик имеет копию репозитория (например, Git, Mercurial).
Примеры:
- Git: популярная распределённая СКВ для проектов любого масштаба.
- Subversion (SVN): централизованная, используется в корпоративных проектах.
- Mercurial: распределённая, с простым интерфейсом.
- CVS: одна из первых СКВ, сейчас менее популярна.
- Perforce: коммерческая, для больших команд.
- TFS: инструмент от Microsoft с функциями контроля версий.

2. Что такое HTTP- и HTTPS-протоколы, методы HTTP-запроса, HTTP-заголовки и группы кодов состояния?
Ответ: 
- HTTP (HyperText Transfer Protocol): протокол для передачи данных в интернете.
- HTTPS: защищённая версия HTTP с шифрованием через SSL/TLS.
Методы HTTP-запроса:
- GET: запрашивает данные.
- POST: отправляет данные для создания ресурса.
- PUT: обновляет ресурс.
- DELETE: удаляет ресурс.
- HEAD: запрашивает заголовки без тела.
- OPTIONS: запрашивает поддерживаемые методы.
- PATCH: частично обновляет ресурс.
HTTP-заголовки:
- Запроса: Host, User-Agent, Accept.
- Ответа: Content-Type, Content-Length, Set-Cookie.
- Общие: Cache-Control, Connection.
Группы кодов состояния:
- 1xx (информационные): 100 Continue.
- 2xx (успех): 200 OK, 201 Created.
- 3xx (перенаправление): 301 Moved Permanently, 302 Found.
- 4xx (ошибка клиента): 400 Bad Request, 404 Not Found.
- 5xx (ошибка сервера): 500 Internal Server Error, 503 Service Unavailable.

3. Что такое клиент-серверная архитектура, назначение блоков, технические устройства и связь базы данных с интерфейсом?
Ответ: Клиент-серверная архитектура — модель, где клиенты запрашивают ресурсы у серверов.
Назначение блоков:
- Клиент: инициирует запросы, отображает данные, обрабатывает ввод.
- Сервер: обрабатывает запросы, выполняет бизнес-логику, взаимодействует с БД.
Технические устройства:
- Клиентская часть: ПК, смартфоны, тонкие клиенты; ПО — браузеры, мобильные/десктопные приложения.
- Серверная часть: серверы, облачные серверы; ПО — веб-серверы (Apache, Nginx), платформы (Node.js, Django), СУБД (MySQL, PostgreSQL).
Связь базы данных с интерфейсом:
- Сервер принимает запросы клиента, формирует SQL-запросы к БД.
- Данные обрабатываются и возвращаются клиенту (например, в JSON).
- Клиент отображает данные в интерфейсе.

4. Что такое модель TCP/IP, назначение её уровней, протоколы и маршрутизация?
Ответ: Модель TCP/IP — основа обмена данными в интернете, состоит из четырёх уровней.
Уровни и протоколы:
- Уровень приложений: HTTP/HTTPS, FTP, SMTP, DNS.
- Транспортный: TCP (надёжный), UDP (ненадёжный).
- Сетевой: IP (маршрутизация), ICMP (управление).
- Канальный: Ethernet, Wi-Fi, PPP.
Маршрутизация:
- Назначение: определение пути передачи данных.
- Классификация:
  - Статическая: ручная настройка маршрутов.
  - Динамическая: автоматическое обновление (RIP, OSPF, BGP).
- Функции: определение маршрута, обновление таблиц, обработка пакетов, управление трафиком.

5. Каково назначение API?
Ответ: API (Application Programming Interface) — набор правил для взаимодействия приложений.
Назначение:
- Интеграция приложений.
- Упрощение разработки.
- Стандартизация доступа.
- Обеспечение безопасности.
- Расширяемость.
- Поддержка мобильных/веб-приложений.
- Управление данными.
- Поддержка микросервисов.
Примеры: API Facebook, Google Maps, Stripe.

6. Какие формы представления данных существуют? Опишите JSON и XML.
Ответ: 
JSON (JavaScript Object Notation):
- Описание: легковесный формат, основан на парах ключ-значение.
- Структура: строки, числа, логические значения, массивы, объекты.
- Преимущества: лёгкость, простота, совместимость с JavaScript, быстрая обработка.
- Недостатки: нет схем, ограниченные типы данных.
Пример:
{
  "name": "Alice",
  "age": 30,
  "courses": ["Mathematics", "Physics"]
}
XML (eXtensible Markup Language):
- Описание: метаязык для структурированных данных с пользовательскими тегами.
- Структура: иерархия тегов, атрибуты, вложенные элементы.
- Преимущества: гибкость, поддержка схем (XSD), сложные типы данных.
- Недостатки: большой объём, сложность, медленная обработка.
Пример:
<person>
  <name>Alice</name>
  <age>30</age>
  <courses>
    <course>Mathematics</course>
    <course>Physics</course>
  </courses>
</person>

7. Как осуществляется аутентификация и авторизация пользователей в клиент-серверных приложениях?
Ответ: 
Аутентификация: проверка подлинности пользователя.
- Методы:
  - Парольная: логин и пароль.
  - Многофакторная (MFA): пароль + код/биометрия.
  - Через соцсети: вход через Google, Facebook.
  - Токены: JWT для доступа.
Авторизация: определение прав доступа.
- Методы:
  - Ролевой доступ (RBAC): роли (админ, пользователь).
  - Список контроля доступа (ACL): доступ к ресурсам.
  - Политики доступа: правила по времени/условиям.
Процесс:
- Аутентификация: ввод данных, проверка, выдача сессии/токена.
- Авторизация: проверка прав для доступа/действий.
Примеры: сессии/куки в веб-приложениях, OAuth, JWT в API.

8. Как осуществляется масштабирование клиент-серверных приложений?
Ответ: Масштабирование — увеличение производительности для обработки нагрузки.
Виды:
- Вертикальное (Scale Up): добавление ресурсов (CPU, RAM) на сервер.
  - Преимущества: простота.
  - Недостатки: ограничения ресурсов, простои.
- Горизонтальное (Scale Out): добавление серверов.
  - Преимущества: высокая доступность.
  - Недостатки: сложность управления.
Подходы:
- Шардинг/репликация БД.
- Кэширование (Redis, Memcached).
- Балансировка нагрузки (Nginx, HAProxy).
- Микросервисная архитектура.
- Контейнеризация (Docker, Kubernetes).
Примеры: веб-сайты с кэшированием, мобильные приложения с облачным масштабированием.

[Тема: Сетевое программирование]
1. Что такое система контроля версий, какие её виды и примеры?
Ответ: Система контроля версий (СКВ) — инструмент для отслеживания изменений в коде, управления версиями файлов и совместной работы.
Виды СКВ:
- Локальные: изменения хранятся локально (например, RCS).
- Централизованные: центральный сервер хранит проект (например, Subversion (SVN), CVS).
- Распределённые: каждый разработчик имеет копию репозитория (например, Git, Mercurial).
Примеры:
- Git: популярная распределённая СКВ для проектов любого масштаба.
- Subversion (SVN): централизованная, используется в корпоративных проектах.
- Mercurial: распределённая, с простым интерфейсом.
- CVS: одна из первых СКВ, сейчас менее популярна.
- Perforce: коммерческая, для больших команд.
- TFS: инструмент от Microsoft с функциями контроля версий.

2. Что такое HTTP- и HTTPS-протоколы, методы HTTP-запроса, HTTP-заголовки и группы кодов состояния?
Ответ: 
- HTTP (HyperText Transfer Protocol): протокол для передачи данных в интернете.
- HTTPS: защищённая версия HTTP с шифрованием через SSL/TLS.
Методы HTTP-запроса:
- GET: запрашивает данные.
- POST: отправляет данные для создания ресурса.
- PUT: обновляет ресурс.
- DELETE: удаляет ресурс.
- HEAD: запрашивает заголовки без тела.
- OPTIONS: запрашивает поддерживаемые методы.
- PATCH: частично обновляет ресурс.
HTTP-заголовки:
- Запроса: Host, User-Agent, Accept.
- Ответа: Content-Type, Content-Length, Set-Cookie.
- Общие: Cache-Control, Connection.
Группы кодов состояния:
- 1xx (информационные): 100 Continue.
- 2xx (успех): 200 OK, 201 Created.
- 3xx (перенаправление): 301 Moved Permanently, 302 Found.
- 4xx (ошибка клиента): 400 Bad Request, 404 Not Found.
- 5xx (ошибка сервера): 500 Internal Server Error, 503 Service Unavailable.

3. Что такое клиент-серверная архитектура, назначение блоков, технические устройства и связь базы данных с интерфейсом?
Ответ: Клиент-серверная архитектура — модель, где клиенты запрашивают ресурсы у серверов.
Назначение блоков:
- Клиент: инициирует запросы, отображает данные, обрабатывает ввод.
- Сервер: обрабатывает запросы, выполняет бизнес-логику, взаимодействует с БД.
Технические устройства:
- Клиентская часть: ПК, смартфоны, тонкие клиенты; ПО — браузеры, мобильные/десктопные приложения.
- Серверная часть: серверы, облачные серверы; ПО — веб-серверы (Apache, Nginx), платформы (Node.js, Django), СУБД (MySQL, PostgreSQL).
Связь базы данных с интерфейсом:
- Сервер принимает запросы клиента, формирует SQL-запросы к БД.
- Данные обрабатываются и возвращаются клиенту (например, в JSON).
- Клиент отображает данные в интерфейсе.

4. Что такое модель TCP/IP, назначение её уровней, протоколы и маршрутизация?
Ответ: Модель TCP/IP — основа обмена данными в интернете, состоит из четырёх уровней.
Уровни и протоколы:
- Уровень приложений: HTTP/HTTPS, FTP, SMTP, DNS.
- Транспортный: TCP (надёжный), UDP (ненадёжный).
- Сетевой: IP (маршрутизация), ICMP (управление).
- Канальный: Ethernet, Wi-Fi, PPP.
Маршрутизация:
- Назначение: определение пути передачи данных.
- Классификация:
  - Статическая: ручная настройка маршрутов.
  - Динамическая: автоматическое обновление (RIP, OSPF, BGP).
- Функции: определение маршрута, обновление таблиц, обработка пакетов, управление трафиком.

5. Каково назначение API?
Ответ: API (Application Programming Interface) — набор правил для взаимодействия приложений.
Назначение:
- Интеграция приложений.
- Упрощение разработки.
- Стандартизация доступа.
- Обеспечение безопасности.
- Расширяемость.
- Поддержка мобильных/веб-приложений.
- Управление данными.
- Поддержка микросервисов.
Примеры: API Facebook, Google Maps, Stripe.

6. Какие формы представления данных существуют? Опишите JSON и XML.
Ответ: 
JSON (JavaScript Object Notation):
- Описание: легковесный формат, основан на парах ключ-значение.
- Структура: строки, числа, логические значения, массивы, объекты.
- Преимущества: лёгкость, простота, совместимость с JavaScript, быстрая обработка.
- Недостатки: нет схем, ограниченные типы данных.
Пример:
{
  "name": "Alice",
  "age": 30,
  "courses": ["Mathematics", "Physics"]
}
XML (eXtensible Markup Language):
- Описание: метаязык для структурированных данных с пользовательскими тегами.
- Структура: иерархия тегов, атрибуты, вложенные элементы.
- Преимущества: гибкость, поддержка схем (XSD), сложные типы данных.
- Недостатки: большой объём, сложность, медленная обработка.
Пример:
<person>
  <name>Alice</name>
  <age>30</age>
  <courses>
    <course>Mathematics</course>
    <course>Physics</course>
  </courses>
</person>

7. Как осуществляется аутентификация и авторизация пользователей в клиент-серверных приложениях?
Ответ: 
Аутентификация: проверка подлинности пользователя.
- Методы:
  - Парольная: логин и пароль.
  - Многофакторная (MFA): пароль + код/биометрия.
  - Через соцсети: вход через Google, Facebook.
  - Токены: JWT для доступа.
Авторизация: определение прав доступа.
- Методы:
  - Ролевой доступ (RBAC): роли (админ, пользователь).
  - Список контроля доступа (ACL): доступ к ресурсам.
  - Политики доступа: правила по времени/условиям.
Процесс:
- Аутентификация: ввод данных, проверка, выдача сессии/токена.
- Авторизация: проверка прав для доступа/действий.
Примеры: сессии/куки в веб-приложениях, OAuth, JWT в API.

8. Как осуществляется масштабирование клиент-серверных приложений?
Ответ: Масштабирование — увеличение производительности для обработки нагрузки.
Виды:
- Вертикальное (Scale Up): добавление ресурсов (CPU, RAM) на сервер.
  - Преимущества: простота.
  - Недостатки: ограничения ресурсов, простои.
- Горизонтальное (Scale Out): добавление серверов.
  - Преимущества: высокая доступность.
  - Недостатки: сложность управления.
Подходы:
- Шардинг/репликация БД.
- Кэширование (Redis, Memcached).
- Балансировка нагрузки (Nginx, HAProxy).
- Микросервисная архитектура.
- Контейнеризация (Docker, Kubernetes).
Примеры: веб-сайты с кэшированием, мобильные приложения с облачным масштабированием.

[Тема: Сетевое программирование - Практика]
1. Проанализируйте GET-запрос с сайта https://www.uisi.ru/uisi/general/news.php при помощи Postman.
Ответ: 
Результат запроса:
Сервер вернул HTML-страницу с кодом ответа 200 OK, что указывает на успешную доставку контента.
Структура полученного ответа:
- Подключение стилей и скриптов:
  - CSS-файлы: style.css, ajax.css, template_styles.css и др.
  - JavaScript-файлы: ajax.js, jquery.min.js, special.js (для динамики и версии для слабовидящих).
- Навигационные элементы:
  - Верхнее меню сайта.
  - Меню «Для слабовидящих».
  - Ссылки на соцсети: Rutube, Telegram, VK.
- Меню разделов сайта: Сведения об образовательной организации, Институт, Наука, Библиотека, Мультимедиа и др.
- Список новостей (в тегах <p class="news-item">):
  - Дата публикации (<span class="news-date-time">).
  - Заголовок и ссылка на полную версию (<a href="..."><b>...</b></a>).
  Пример:
  - 05.05.2025 — «Праздничный концерт уже завтра!»
  - 05.05.2025 — «Фотобудка празднования юбилея УрТИСИ СибГУТИ»
  - 01.05.2025 — «Праздник Весны и Труда»
- Постраничная навигация: ссылки на страницы через параметр PAGEN_1 (например, ?PAGEN_1=2, ?PAGEN_1=3).
Вывод:
GET-запрос возвращает стандартную HTML-страницу, сформированную сервером. Данные о новостях представлены в теле ответа, что упрощает парсинг. Навигация использует query-параметр PAGEN_1. Сайт не использует REST API, а отдаёт HTML по классическому запросу. Поддерживается версия для слабовидящих.

2. Проанализируйте GET-запрос с сайта https://mail.ru при помощи Postman.
Ответ: 
Результат запроса:
- Первоначальный ответ: код 301 Moved Permanently или 302 Found (перенаправление на HTTPS или поддомен).
- После перенаправления (с включённым Follow redirects): HTML-страница с кодом 200 OK.
Структура полученного ответа:
- Динамическая структура: контент (почта, лента, авторизация) подгружается асинхронно через JavaScript (AJAX).
- Редиректы и куки: заголовки содержат Set-Cookie, Location для сессий и авторизации.
- Инструменты аналитики: ссылки на Яндекс.Метрика, Google Analytics.
Вывод:
Mail.ru использует перенаправления, динамическую подгрузку данных и сессионные механизмы. HTML содержит базовую структуру, а функционал реализуется через JavaScript. Для анализа контента лучше использовать браузерную консоль или отладчик сети, так как Postman показывает только начальный HTML.

3. Создайте страницу с информацией о студенте и любимым стихотворением, используя различные стили текста через файл style.css.
Ответ: Создадим HTML-страницу и CSS-файл для отображения информации о студенте и стихотворения с применением стилей (курсив, жирный, подчёркнутый, перечёркнутый).

index.html:
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Информация о студенте</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <h1>Студент: Иванов И.О.</h1>

  <h2>Моё любимое стихотворение:</h2>

  <p>
    <span class="bold">Вечер</span> настал, <span class="italic">тихо</span> и <span class="underline">нежно</span>,<br>
    В <span class="strike">прохладных</span> тенях <span class="bold-italic">звезды</span> блестят.<br>
    Легкий <span class="italic">шёпот</span> ветра <span class="underline">сквозь</span> листья мчится,<br>
    И <span class="bold">ночь</span> <span class="strike">уносит</span> дни прочь.
  </p>
</body>
</html>

style.css:
body {
  font-family: 'Arial', sans-serif;
  margin: 30px;
  background-color: #f0f8ff;
  color: #333;
}

h1 {
  color: #2a52be;
}

h2 {
  color: #5a5a5a;
  margin-top: 20px;
}

.bold {
  font-weight: bold;
}

.italic {
  font-style: italic;
}

.underline {
  text-decoration: underline;
}

.strike {
  text-decoration: line-through;
}

.bold-italic {
  font-weight: bold;
  font-style: italic;
}

Вывод: Страница отображает имя студента и стихотворение с различными стилями текста, подключёнными через внешний CSS-файл. Стили включают жирный, курсив, подчёркнутый, перечёркнутый и комбинированный (жирный+курсив) текст.

4. Разработайте веб-приложение для расчёта гипотенузы и площади прямоугольного треугольника с катетами a, b.
Ответ: Создадим HTML-страницу с JavaScript для ввода катетов, вычисления гипотенузы и площади, и отображения результатов.

index.html:
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Расчет гипотенузы и площади</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 400px;
      margin: 40px auto;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    label, input, button {
      display: block;
      width: 100%;
      margin-bottom: 10px;
    }
    button {
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    .result {
      margin-top: 20px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>Расчет гипотенузы и площади треугольника</h2>
  
  <label for="a">Катет a:</label>
  <input type="number" id="a" step="any" min="0" placeholder="Введите длину катета a" />

  <label for="b">Катет b:</label>
  <input type="number" id="b" step="any" min="0" placeholder="Введите длину катета b" />

  <button onclick="calculate()">Вычислить</button>

  <div class="result" id="result"></div>

  <script>
    function calculate() {
      const a = parseFloat(document.getElementById('a').value);
      const b = parseFloat(document.getElementById('b').value);
      const resultDiv = document.getElementById('result');
      
      if (isNaN(a) || isNaN(b) || a <= 0 || b <= 0) {
        resultDiv.textContent = 'Пожалуйста, введите корректные положительные значения для катетов a и b.';
        return;
      }

      const hypotenuse = Math.sqrt(a * a + b * b);
      const area = (a * b) / 2;

      resultDiv.innerHTML = `Гипотенуза: <strong>${hypotenuse.toFixed(3)}</strong><br>Площадь: <strong>${area.toFixed(3)}</strong>`;
    }
  </script>
</body>
</html>

Вывод: Веб-приложение позволяет ввести катеты a и b, вычисляет гипотенузу (по теореме Пифагора) и площадь треугольника (S = (a*b)/2). Результаты отображаются с точностью до трёх знаков после запятой. Проверка корректности ввода предотвращает ошибки.

[Тема: Программирование]
1. Построить 3D график по следующим формулам:
x = u * cos(u) * (cos(v) + 1)
y = u * sin(u) * (cos(v) + 1)
z = u * sin(v)
u ∈ [0; 3π], v ∈ [-π; π]
Графиков должно быть два: каркасный и сплошной – разных цветов.

Ответ: Используем Python с библиотекой Matplotlib для построения двух 3D-графиков: каркасного (wireframe) и сплошного (surface).

Код:
import numpy as np
import matplotlib.pyplot as plt

# Параметры
u = np.linspace(0, 3 * np.pi, 100)
v = np.linspace(-np.pi, np.pi, 100)
U, V = np.meshgrid(u, v)

# Параметрические уравнения
X = U * np.cos(U) * (np.cos(V) + 1)
Y = U * np.sin(U) * (np.cos(V) + 1)
Z = U * np.sin(V)

# Создаём фигуру с двумя подграфиками
fig = plt.figure(figsize=(12, 6))

# 1. Каркасный график (wireframe)
ax1 = fig.add_subplot(121, projection='3d')
ax1.plot_wireframe(X, Y, Z, color='purple', rstride=5, cstride=5)
ax1.set_title("Каркасная поверхность", pad=10)
ax1.set_xlabel("X")
ax1.set_ylabel("Y")
ax1.set_zlabel("Z")

# 2. Сплошной график (surface)
ax2 = fig.add_subplot(122, projection='3d')
ax2.plot_surface(X, Y, Z, color='cyan', alpha=0.8)
ax2.set_title("Сплошная поверхность", pad=10)
ax2.set_xlabel("X")
ax2.set_ylabel("Y")
ax2.set_zlabel("Z")

plt.tight_layout()
plt.show()

Вывод: Код создаёт два графика: каркасный (фиолетовый) и сплошной (голубой), отображающие параметрическую поверхность. Параметры u и v задают диапазоны, а сетка (100x100) обеспечивает гладкость.

2. Построить график полярной розы в полярной системе координат по формуле r = sin(7/4 * t).

Ответ: Используем Matplotlib для построения полярной розы с формулой r(t) = sin(7/4 * t).

Код:
import numpy as np
import matplotlib.pyplot as plt

# Создаем массив углов t от 0 до 8π
t = np.linspace(0, 8 * np.pi, 1000)

# Вычисляем радиус r(t) = sin(7/4 * t)
r = np.sin((7 / 4) * t)

# Создаем полярный график
plt.figure(figsize=(8, 8))
ax = plt.subplot(111, polar=True)  # Полярная проекция

# Рисуем розу
ax.plot(t, r, color='magenta', linewidth=2)

# Настраиваем график
ax.set_title("Полярная роза: $r(t) = \\sin\\left(\\frac{7}{4}t\\right)$", pad=20)
ax.grid(True)
plt.show()

Вывод: График отображает полярную розу с 7 лепестками (число лепестков определяется коэффициентом 7/4). Цвет — пурпурный, сетка включена для наглядности.

3. Построить график спирали по формуле: x = t * sin(t), y = t * cos(t), t ∈ [0; 5π].

Ответ: Используем Matplotlib для построения спирали.

Код:
import numpy as np
import matplotlib.pyplot as plt

# Создаем массив параметра t от 0 до 5π
t = np.linspace(0, 5 * np.pi, 500)

# Вычисляем координаты x и y
x = t * np.sin(t)
y = t * np.cos(t)

# Создаем график
plt.figure(figsize=(8, 8))
plt.plot(x, y, color='blue', linewidth=2)

# Настраиваем график
plt.title("Спираль: $x = t \\cdot \\sin(t)$, $y = t \\cdot \\cos(t)$", fontsize=14)
plt.xlabel("$x$", fontsize=12)
plt.ylabel("$y$", fontsize=12)
plt.grid(True)
plt.axis('equal')  # Для одинакового масштаба по осям
plt.show()

Вывод: Код создаёт график спирали синего цвета, которая разворачивается от центра. Одинаковый масштаб осей (axis='equal') обеспечивает корректное отображение формы.

4. Разработать форму для ввода информации о студентах (ФИО, № группы, 3 оценки) в базу данных с выводом содержимого в текстовое окно.

Ответ: Используем Tkinter и SQLite для создания графической формы.

Код:
import tkinter as tk
from tkinter import messagebox
import sqlite3

# Создание базы данных и таблицы
conn = sqlite3.connect('students.db')
cursor = conn.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS students (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        full_name TEXT NOT NULL,
        group_number TEXT NOT NULL,
        grade1 INTEGER NOT NULL,
        grade2 INTEGER NOT NULL,
        grade3 INTEGER NOT NULL
    )
''')
conn.commit()

def add_student():
    full_name = entry_name.get()
    group_number = entry_group.get()
    grade1 = entry_grade1.get()
    grade2 = entry_grade2.get()
    grade3 = entry_grade3.get()
    if not all([full_name, group_number, grade1, grade2, grade3]):
        messagebox.showerror("Ошибка", "Все поля должны быть заполнены!")
        return
    try:
        cursor.execute('''
            INSERT INTO students (full_name, group_number, grade1, grade2, grade3)
            VALUES (?, ?, ?, ?, ?)
        ''', (full_name, group_number, int(grade1), int(grade2), int(grade3)))
        conn.commit()
        messagebox.showinfo("Успех", "Студент добавлен в базу данных!")
        clear_entries()
    except ValueError:
        messagebox.showerror("Ошибка", "Оценки должны быть числами!")

def show_students():
    cursor.execute('SELECT * FROM students')
    students = cursor.fetchall()
    text_output.delete(1.0, tk.END)
    if not students:
        text_output.insert(tk.END, "База данных пуста.")
    else:
        text_output.insert(tk.END, "Список студентов:\n\n")
        for student in students:
            text_output.insert(tk.END, 
                f"ID: {student[0]}\n"
                f"ФИО: {student[1]}\n"
                f"Группа: {student[2]}\n"
                f"Оценки: {student[3]}, {student[4]}, {student[5]}\n"
                f"{'-'*30}\n"
            )

def clear_entries():
    entry_name.delete(0, tk.END)
    entry_group.delete(0, tk.END)
    entry_grade1.delete(0, tk.END)
    entry_grade2.delete(0, tk.END)
    entry_grade3.delete(0, tk.END)

# Создание графического интерфейса
root = tk.Tk()
root.title("База данных студентов")
root.geometry("600x500")

# Поля для ввода
tk.Label(root, text="ФИО:").grid(row=0, column=0, padx=10, pady=5, sticky="e")
entry_name = tk.Entry(root, width=30)
entry_name.grid(row=0, column=1, padx=10, pady=5)

tk.Label(root, text="Номер группы:").grid(row=1, column=0, padx=10, pady=5, sticky="e")
entry_group = tk.Entry(root, width=30)
entry_group.grid(row=1, column=1, padx=10, pady=5)

tk.Label(root, text="Оценка 1:").grid(row=2, column=0, padx=10, pady=5, sticky="e")
entry_grade1 = tk.Entry(root, width=30)
entry_grade1.grid(row=2, column=1, padx=10, pady=5)

tk.Label(root, text="Оценка 2:").grid(row=3, column=0, padx=10, pady=5, sticky="e")
entry_grade2 = tk.Entry(root, width=30)
entry_grade2.grid(row=3, column=1, padx=10, pady=5)

tk.Label(root, text="Оценка 3:").grid(row=4, column=0, padx=10, pady=5, sticky="e")
entry_grade3 = tk.Entry(root, width=30)
entry_grade3.grid(row=4, column=1, padx=10, pady=5)

# Кнопки
button_frame = tk.Frame(root)
button_frame.grid(row=5, column=0, columnspan=2, pady=10)
btn_add = tk.Button(button_frame, text="Добавить студента", command=add_student)
btn_add.pack(side=tk.LEFT, padx=5)
btn_show = tk.Button(button_frame, text="Показать всех", command=show_students)
btn_show.pack(side=tk.LEFT, padx=5)
btn_clear = tk.Button(button_frame, text="Очистить поля", command=clear_entries)
btn_clear.pack(side=tk.LEFT, padx=5)

# Текстовое поле для вывода
text_output = tk.Text(root, width=70, height=20)
text_output.grid(row=6, column=0, columnspan=2, padx=10, pady=10)

root.mainloop()
conn.close()

Вывод: Форма позволяет добавлять студентов в базу SQLite, отображать список студентов с их данными и очищать поля ввода. Проверки ввода предотвращают ошибки.

5. Построить график функции y = 2x² + 4, создать массивы x и y, найти минимальное значение y.

Ответ: Используем NumPy и Matplotlib для создания массивов, построения графика и нахождения минимума.

Код:
import numpy as np
import matplotlib.pyplot as plt

# Создаем массив x от -5 до 5 с шагом 0.1
x = np.arange(-5, 5.1, 0.1)

# Вычисляем массив y по формуле y = 2x^2 + 4
y = 2 * x ** 2 + 4

# Находим минимальное значение y
min_y = np.min(y)

# Выводим результаты
print("Массив x:", x)
print("Массив y:", y)
print("Минимальное значение y:", min_y)

plt.plot(x, y)
plt.title("График функции y = 2x² + 4")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.show()

Вывод: Минимальное значение y = 4 (при x = 0). График отображает параболу, открытую вверх.

[Тема: Структуры и алгоритмы обработки данных]
1. Нарисуйте дерево, соответствующее префиксному выражению * a + b * c + d e.

Ответ: Префиксное выражение * a + b * c + d e интерпретируется как дерево, где операторы — узлы, а операнды — листья. Разберём выражение:
- Первый оператор * — корень.
- Левый операнд — a.
- Правый операнд — + b * c + d e.
- Для +: левое поддерево — b, правое — * c + d e.
- Для *: левое — c, правое — + d e.
- Для +: левое — d, правое — e.

Дерево:
       *
      / \
     a   +
        / \
       b   *
          / \
         c   +
            / \
           d   e

Вывод: Дерево построено, где * — корень, a и поддерево + — дети, и так далее.

2. Преобразуйте выражение ((a+b)+c*(d+e)+f)*(g+h) в префиксную форму.

Ответ: Разберём пошагово:
- ((a+b)+c*(d+e)+f)*(g+h) = ((+ a b) + (* c (+ d e)) + f) * (+ g h)
- Сливаем внутренние подвыражения: (+ (+ a b) (* c (+ d e)) f) * (+ g h)
- Итог: * + + a b * c + d e f + g h

Префиксная форма: * + + a b * c + d e f + g h

Вывод: Выражение преобразовано корректно, порядок операторов соответствует префиксной нотации.

3. Преобразуйте выражение ((a+b)+c*(d+e)+f)*(g+h) в постфиксную форму.

Ответ: Разберём пошагово:
- ((a+b)+c*(d+e)+f)*(g+h) = ((a b +) + (c d e + *) + f) * (g h +)
- Сливаем: (a b + c d e + * + f +) (g h + *)
- Итог: a b + c d e + * + f + g h + *

Постфиксная форма: a b + c d e + * + f + g h + *

Вывод: Выражение преобразовано в постфиксную нотацию.

4. Графы. Обходы графов.

Ответ: 
Граф — структура данных G = (V, E), где V — вершины, E — рёбра.
Типы графов:
- Ориентированные: рёбра направлены.
- Неориентированные: рёбра без направления.
- Взвешенные: рёбра с весами.
- Невзвешенные: рёбра без весов.
- Связные: путь между любой парой вершин.
- Ациклические: без циклов (например, деревья).

Обходы графов:
- Поиск в глубину (DFS):
  - Идея: углубляться по рёбрам, возвращаться при тупиках.
  - Реализация: стек (рекурсия или явно), множество посещённых вершин.
  - Применение: поиск путей, проверка циклов, топологическая сортировка.
  - Код:
    visited = set()
    def dfs(node):
        if node not in visited:
            visited.add(node)
            print(node)
            for neighbor in graph[node]:
                dfs(neighbor)
  - Сложность: O(V + E).
- Поиск в ширину (BFS):
  - Идея: послойное исследование графа.
  - Реализация: очередь, множество посещённых вершин.
  - Применение: кратчайшие пути в невзвешенных графах.
  - Код:
    from collections import deque
    def bfs(start):
        visited = set()
        queue = deque([start])
        visited.add(start)
        while queue:
            node = queue.popleft()
            print(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
  - Сложность: O(V + E).

Вывод: DFS и BFS решают разные задачи, DFS экономичнее по памяти, BFS подходит для поиска кратчайших путей.

5. Графы. Способы реализации.

Ответ: 
Способы реализации графов:
- Список смежности:
  - Структура: словарь/массив, где ключ — вершина, значение — список соседей.
  - Пример: {A: [B, C], B: [A, C], C: [A, B]}.
  - Преимущества: O(V + E) памяти, быстрое перечисление соседей.
  - Недостатки: проверка ребра O(степень вершины).
- Матрица смежности:
  - Структура: матрица V×V, matrix[u][v] = 1 (или вес) при наличии ребра.
  - Пример: [[0, 1, 1], [1, 0, 1], [1, 1, 0]].
  - Преимущества: O(1) проверка ребра, подходит для плотных графов.
  - Недостатки: O(V²) памяти, медленно для разреженных графов.
- Список рёбер:
  - Структура: список пар (u, v) или троек (u, v, вес).
  - Пример: [(A, B), (A, C), (B, C)].
  - Преимущества: O(E) памяти, подходит для перебора рёбер.
  - Недостатки: медленный доступ к соседям.
- Матрица инцидентности:
  - Структура: матрица V×E, matrix[u][e] = 1 (или -1 для ориентированных графов) при участии вершины в ребре.
  - Пример: [[1, 1, 0], [1, 0, 1], [0, 1, 1]].
  - Преимущества: анализ рёбер, матричные операции.
  - Недостатки: O(V×E) памяти, медленно для обходов.

Вывод: Список смежности оптимален для разреженных графов, матрица смежности — для плотных, список рёбер — для алгоритмов на рёбрах.

6. Графы. Построение минимального остовного дерева (МОД).

Ответ: 
МОД — поддерево, соединяющее все вершины с минимальной суммой весов рёбер.
Алгоритмы:
- Крускал:
  - Шаги: сортировка рёбер по весу, добавление рёбер без циклов (с DSU).
  - Сложность: O(E log E).
  - Подходит для разреженных графов.
- Прим:
  - Шаги: выбор вершины, добавление минимального ребра к новым вершинам.
  - Сложность: O(E log V) с кучей.
  - Подходит для плотных графов.

Вывод: Крускал эффективен для разреженных графов, Прим — для плотных.

7. Графы. Кратчайшие расстояния.

Ответ: 
Алгоритмы:
- BFS: для невзвешенных графов, O(V + E).
- Дейкстра: для взвешенных графов без отрицательных весов, O(E log V).
- Беллман-Форд: для графов с отрицательными весами, O(V * E).
- Флойд-Уоршелл: для всех пар вершин, O(V³).

Вывод: Выбор алгоритма зависит от типа графа и требований задачи.

8. Поиск в линейных структурах.

Ответ: 
- Линейный поиск:
  - Алгоритм: последовательная проверка элементов.
  - Сложность: O(n).
  - Код:
    def linear_search(arr, key):
        for i in range(len(arr)):
            if arr[i] == key:
                return i
        return -1
- Двоичный поиск:
  - Алгоритм: деление отсортированного массива пополам.
  - Сложность: O(log n).
  - Код:
    def binary_search(arr, key):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == key:
                return mid
            elif arr[mid] < key:
                left = mid + 1
            else:
                right = mid - 1
        return -1
- Поиск подстроки: прямой поиск O(n*m), KMP более эффективен.
- Поиск в связном списке: линейный, O(n).

Вывод: Двоичный поиск быстрее, но требует сортировки; линейный поиск универсален.

9. АТД - стек. Реализация с помощью указателей.

Ответ: 
Стек — структура LIFO (последний вошёл — первый вышел).
Реализация:
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Stack:
    def __init__(self):
        self.top = None
    
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top
        self.top = new_node
    
    def pop(self):
        if not self.top:
            return None
        data = self.top.data
        self.top = self.top.next
        return data
    
    def is_empty(self):
        return self.top is None

Вывод: Стек реализован как связный список, операции push/pop выполняются за O(1).

10. АТД - список. Реализация с помощью указателей.

Ответ: 
Список — однонаправленный связный список.
Реализация:
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.header = None
    
    def insert(self, data, position):
        new_node = Node(data)
        if position == 1:
            new_node.next = self.header
            self.header = new_node
        else:
            current = self.header
            for _ in range(position - 2):
                if not current:
                    return
                current = current.next
            if current:
                new_node.next = current.next
                current.next = new_node
    
    def delete(self, position):
        if not self.header:
            return
        if position == 1:
            self.header = self.header.next
        else:
            current = self.header
            for _ in range(position - 2):
                if not current:
                    return
                current = current.next
            if current and current.next:
                current.next = current.next.next

Вывод: Список позволяет вставку и удаление за O(n) в худшем случае.

11. Нарисуйте все возможные деревья двоичного поиска для элементов 1, 2, 3, 4.

Ответ: Число деревьев — 14 (число Каталана для n=4). Примеры деревьев:
1.       2
        / \
       1   3
            \
             4
2.       3
        / \
       2   4
      /
     1
3.       1
         \
          2
           \
            3
             \
              4
... (и ещё 11 деревьев, построенных по правилам BST).

Вывод: Все деревья удовлетворяют свойству BST (левое поддерево < узел < правое).

12. АТД - очередь. Реализация с помощью указателей.

Ответ: 
Очередь — структура FIFO (первый вошёл — первый вышел).
Реализация:
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
    
    def enqueue(self, data):
        new_node = Node(data)
        if not self.rear:
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
    
    def dequeue(self):
        if not self.front:
            return None
        data = self.front.data
        self.front = self.front.next
        if not self.front:
            self.rear = None
        return data
    
    def is_empty(self):
        return self.front is None

Вывод: Очередь реализована как связный список, операции enqueue/dequeue — O(1).

[Тема: Теория массового обслуживания]

1. Предмет теории массового обслуживания. Основные понятия теории.
Ответ:
Теория массового обслуживания (ТМО) — раздел теории вероятностей, изучающий математические методы оценки процессов функционирования систем, обслуживающих случайный поток заявок.

Предмет ТМО:
- Установление зависимостей между потоком заявок, числом каналов, производительностью каналов и эффективностью обслуживания.
- Разработка методов вычисления показателей эффективности систем массового обслуживания (СМО).

Основные понятия:
- Система массового обслуживания (СМО): система для обработки заявок (например, телефонные станции, магазины, аэропорты).
- Заявка: запрос на обслуживание (например, звонок, клиент, самолёт).
- Поток заявок: последовательность заявок, характеризуемая:
  - Интенсивностью (λ) — среднее число заявок в единицу времени.
  - Ординарностью — заявки поступают поодиночке.
  - Стационарностью — неизменность вероятностных характеристик во времени.
  - Отсутствием последействия — независимость поступления заявок.
- Канал обслуживания: устройство, обрабатывающее заявки, с интенсивностью обслуживания (μ) — среднее число обслуженных заявок в единицу времени.
- Очередь: заявки, ожидающие обслуживания, с дисциплиной (FIFO, LIFO, с приоритетами) и длиной (ограниченная/неограниченная).
- Нотация Кендалла (A/B/C/D/E/F): A — распределение времени между заявками, B — времени обслуживания, C — число каналов, D — ёмкость системы, E — размер источника заявок, F — дисциплина обслуживания.
- Показатели эффективности:
  - Относительная пропускная способность (q) — доля обслуженных заявок.
  - Абсолютная пропускная способность (A) — число обслуженных заявок в единицу времени.
  - Вероятность отказа (Pотк) — вероятность ухода заявки без обслуживания.
  - Средняя длина очереди (Lоч).
  - Среднее время ожидания в очереди (Wоч).
  - Среднее число заявок в системе (L).
  - Среднее время пребывания в системе (W).

2. Классификация систем массового обслуживания.
Ответ:
Классификация СМО:
- По поступлению заявок:
  - Регулярный поток — заявки через фиксированные интервалы.
  - Случайный поток: пуассоновский (стационарный, ординарный, без последействия) или непуассоновский.
- По числу каналов:
  - Одноканальные.
  - Многоканальные.
- По дисциплине обслуживания:
  - FIFO — первым пришёл, первым обслужен.
  - LIFO — последним пришёл, первым обслужен.
  - SIRO — случайный порядок.
  - С приоритетами (абсолютный/относительный).
- По длине очереди:
  - Неограниченная очередь.
  - Ограниченная очередь.
  - С отказами (без очереди).
- По числу фаз обслуживания:
  - Однофазные.
  - Многофазные.
- По времени обслуживания:
  - Детерминированное.
  - Случайное (экспоненциальное, произвольное).
- По источнику заявок:
  - Бесконечный источник.
  - Конечный источник.
- По зависимости каналов:
  - Независимые.
  - Зависимые.

Нотация Кендалла:
- A, B: M (экспоненциальное), D (детерминированное), G (произвольное), E_k (Эрланга).
- Примеры: M/M/1, M/D/5/10, G/G/k.

3. Задача минимизации штрафа за задержку обслуживания.
Ответ:
Задача: найти оптимальное число каналов (n), минимизирующее затраты на каналы и штрафы за ожидание.

Модель:
- λ — интенсивность поступления заявок.
- μ — интенсивность обслуживания одного канала.
- c₁ — стоимость содержания одного канала в единицу времени.
- c₂ — штраф за ожидание одной заявки в единицу времени.

Целевая функция:
F(n) = c₁ × n + c₂ × Lq × λ, где Lq — средняя длина очереди.

Для M/M/n:
Lq = (P₀ × (λ/μ)ⁿ × ρ) / (n! × (1-ρ)²), где ρ = λ/(n×μ), P₀ — вероятность отсутствия заявок.

Алгоритм:
Вычислить Lq для разных n.
Подставить в F(n).
Найти n, минимизирующее F(n).

Методы:
- Аналитический (производная F(n)).
- Численный (перебор).
- Имитационное моделирование.

4. Задача «директора» (одного станка).
Ответ:
Задача: найти оптимальное число ремонтников (n) для станка, минимизирующее потери от простоя и затраты на ремонтников.

Модель:
- λ — интенсивность отказов станка.
- μ — интенсивность ремонта одним ремонтником.
- c₁ — потери от простоя в единицу времени.
- c₂ — затраты на одного ремонтника в единицу времени.

Состояния:
- S₀ — станок работает.
- S₁ — станок в ремонте.

Вероятности:
- P₀ = n×μ / (λ + n×μ).
- P₁ = λ / (λ + n×μ).

Целевая функция:
F(n) = c₁ × P₁ + c₂ × n.

Решение:
- Аналитически: n_опт = (1/μ) × √(c₁ × λ / c₂) - λ/μ.
- Численно: перебор n.

5. Задача двух станков. Алгоритм Джонсона.
Ответ:
Задача: минимизировать время обработки n деталей на двух станках (M₁, M₂), где каждая деталь сначала обрабатывается на M₁, затем на M₂.

Параметры:
- a_i — время обработки детали i на M₁.
- b_i — время обработки детали i на M₂.

Алгоритм Джонсона:
1. Разделить детали на множества:
   - U: a_i ≤ b_i.
   - V: a_i > b_i.
Сортировать U по возрастанию a_i.
Сортировать V по убыванию b_i.
Последовательность: U, затем V.

Сложность: O(n log n).

6. Потоки событий. Простейший поток событий.
Ответ:
Поток событий — последовательность случайных событий (например, поступление заявок).

Характеристики:
- Интенсивность (λ) — среднее число событий в единицу времени.
- Функция интенсивности λ(t).
- Ведущая функция Λ(t) — среднее число событий за [0, t].

Классификация:
- Стационарный/нестационарный.
- Ординарный/неординарный.
- С последействием/без последействия.

Простейший (пуассоновский) поток:
- Стационарный, ординарный, без последействия.
- P{N(t) = k} = (λt)^k × e^(-λt) / k!.
- Интервалы между событиями — экспоненциальные: f(t) = λe^(-λt).

Применение: звонки, запросы к серверу, отказы компонентов.

7. Случайные процессы. Марковский процесс.
Ответ:
Случайный процесс — семейство случайных величин {X(t), t ∈ T}.

Классификация:
- По T: дискретное/непрерывное время.
- По состояниям: дискретные/непрерывные.
- По характеристикам: стационарные/нестационарные.

Марковский процесс:
- Будущее зависит только от текущего состояния.
- P{X(t) = y | X(tₙ) = xₙ, ...} = P{X(t) = y | X(tₙ) = xₙ}.

Для дискретных состояний:
- Переходные вероятности pᵢⱼ(t, t+s).
- Уравнение Колмогорова-Чепмена: pᵢⱼ(t+s) = ∑ₖ pᵢₖ(t) × pₖⱼ(s).

Применение в ТМО: моделирование числа заявок в M/M/n.

8. Уравнения Колмогорова. Предельные вероятности.
Ответ:
Уравнения Колмогорова описывают эволюцию вероятностей в марковских процессах:
- Прямые: dpᵢⱼ(t)/dt = ∑ₖ pᵢₖ(t) × λₖⱼ.
- Обратные: dpᵢⱼ(t)/dt = ∑ₖ λᵢₖ × pₖⱼ(t).

Предельные вероятности (πⱼ):
- Существуют для эргодических процессов.
- Условия: π × Λ = 0, ∑ᵢ πᵢ = 1.

Для M/M/n:
- πᵢ = π₀ × ρⁱ / i! (i ≤ n), πᵢ = π₀ × ρⁱ / (n! × nⁱ⁻ⁿ) (i > n).

9. Процесс гибели и размножения. Формулы для предельных вероятностей.
Ответ:
Процесс гибели и размножения:
- Переходы только в соседние состояния: λₙ (n → n+1), μₙ (n → n-1).

Предельные вероятности:
- πₙ = π₀ × (λ₀ × λ₁ × ... × λₙ₋₁) / (μ₁ × μ₂ × ... × μₙ).
- π₀ из условия ∑ᵢ πᵢ = 1.

10. Одноканальная СМО с отказами. Расчет показателей эффективности.
Ответ:
Система M/M/1/1:
- Один канал, без очереди, λ — интенсивность поступления, μ — интенсивность обслуживания.

Вероятности:
- p₀ = μ / (λ + μ).
- p₁ = λ / (λ + μ).

Показатели:
- A = λ × p₀ = λμ / (λ + μ).
- q = p₀ = μ / (λ + μ).
- Pотк = p₁ = λ / (λ + μ).
- L = p₁ = λ / (λ + μ).
- W = 1 / μ.
- ρ = λ / μ.

11. Многоканальная СМО с отказами. Расчет показателей эффективности.
Ответ:
Система M/M/n/n:
- n каналов, без очереди, λ, μ.

Вероятности (формула Эрланга):
- p₀ = 1 / ∑ₖ₌₀ⁿ (ρᵏ / k!), ρ = λ / μ.
- pₖ = (ρᵏ / k!) × p₀.

Показатели:
- Pотк = pₙ = (ρⁿ / n!) / ∑ₖ₌₀ⁿ (ρᵏ / k!).
- q = 1 - Pотк.
- A = λ × q.
- k̄ = L = ρ × (1 - Pотк).
- Kз = k̄ / n.
- W = 1 / μ.

12. Одноканальная СМО с неограниченной очередью. Формулы Литтла.
Ответ:
Система M/M/1/∞, ρ = λ / μ < 1.

Вероятности:
- pₖ = (1 - ρ) × ρᵏ.

Показатели:
- L = ρ / (1 - ρ).
- Lq = ρ² / (1 - ρ).
- W = 1 / (μ - λ).
- Wq = ρ / (μ - λ).
- Pw = ρ.

Формулы Литтла:
- L = λ × W.
- Lq = λ × Wq.

13. Многоканальная СМО с неограниченной очередью.
Ответ:
Система M/M/n/∞, ρ = λ / (n × μ) < 1.

Вероятности:
- p₀ = 1 / [∑ₖ₌₀ⁿ⁻¹ (ρn)ᵏ / k! + (ρn)ⁿ / (n! × (1 - ρ))].
- pₖ = (ρn)ᵏ / k! × p₀ (k ≤ n), pₖ = (ρn)ⁿ × ρᵏ⁻ⁿ / n! × p₀ (k > n).

Показатели:
- π = (ρn)ⁿ / (n! × (1 - ρ)) × p₀.
- Lq = π × ρ / (1 - ρ).
- L = Lq + ρn.
- Wq = Lq / λ.
- W = Wq + 1 / μ.
- k̄ = ρn.
- Kз = ρ.

14. Одноканальная СМО с ограниченной очередью.
Ответ:
Система M/M/1/m+1, m — максимальная длина очереди.

Вероятности:
- pₖ = (1 - ρ) × ρᵏ / (1 - ρᵐ⁺¹), k = 0, ..., m+1.

Показатели:
- Pотк = pₘ₊₁ = (1 - ρ) × ρᵐ⁺¹ / (1 - ρᵐ⁺¹).
- q = 1 - Pотк.
- A = λ × q.
- L = ρ × [1 - (m + 2) × ρᵐ⁺¹ + (m + 1) × ρᵐ⁺²] / [(1 - ρ) × (1 - ρᵐ⁺¹)].
- Lq = L - ρ × (1 - Pотк).
- W = L / (λ × q).
- Wq = Lq / (λ × q).
- K = 1 - p₀.

15. Многоканальная СМО с ограниченной очередью.
Ответ:
Система M/M/n/n+m, m — максимальная длина очереди.

Вероятности:
- p₀ = 1 / [∑ₖ₌₀ⁿ⁻¹ (ρn)ᵏ / k! + (ρn)ⁿ / n! × ∑ₖ₌₀ᵐ ρᵏ].
- pₖ = (ρn)ᵏ / k! × p₀ (k ≤ n), pₖ = (ρn)ⁿ × ρᵏ⁻ⁿ / n! × p₀ (n < k ≤ n+m).

Показатели:
- Pотк = pₙ₊ₘ = (ρn)ⁿ × ρᵐ / n! × p₀.
- q = 1 - Pотк.
- A = λ × q.
- Lq = p₀ × (ρn)ⁿ / (n! × (1 - ρ)²) × [1 - ρᵐ - m × ρᵐ × (1 - ρ)].
- L = Lq + ρn × (1 - Pотк).
- Wq = Lq / (λ × q).
- W = Wq + 1 / μ.
- k̄ = ρn × (1 - Pотк).
- Kз = k̄ / n.

[Тема: Теория массового обслуживания практика]

1. Программа для решения задачи минимизации суммарного штрафа.
Ответ:
Код:
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import factorial

def calculate_p0(rho, n):
    sum_part = sum((rho**k) / factorial(k) for k in range(n))
    sum_part += (rho**n) / (factorial(n) * (1 - rho/n))
    return 1 / sum_part

def calculate_Lq(rho, n, p0):
    return (p0 * (rho**n) * rho) / (factorial(n) * (1 - rho/n)**2)

def calculate_total_cost(n, lambda_val, mu, c1, c2):
    rho = lambda_val / mu
    if rho/n >= 1:
        return float('inf')
    p0 = calculate_p0(rho, n)
    Lq = calculate_Lq(rho, n, p0)
    cost_of_channels = c1 * n
    cost_of_delay = c2 * Lq * lambda_val
    return cost_of_channels + cost_of_delay

def find_optimal_n(lambda_val, mu, c1, c2, max_n=30):
    costs = [calculate_total_cost(n, lambda_val, mu, c1, c2) for n in range(1, max_n + 1)]
    optimal_n = np.argmin(costs) + 1
    min_cost = costs[optimal_n - 1]
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, max_n + 1), costs, 'bo-')
    plt.axvline(x=optimal_n, color='r', linestyle='--')
    plt.text(optimal_n + 0.5, min_cost, f'Оптимальное n = {optimal_n}\nМин. затраты = {min_cost:.2f}')
    plt.xlabel('Количество каналов (n)')
    plt.ylabel('Общие затраты')
    plt.title('Зависимость общих затрат от количества каналов')
    plt.grid(True)
    plt.savefig('total_cost.png')
    plt.show()
    return optimal_n, min_cost, costs

if __name__ == "__main__":
    lambda_val = 10
    mu = 3
    c1 = 100
    c2 = 20
    optimal_n, min_cost, costs = find_optimal_n(lambda_val, mu, c1, c2)
    print(f"Оптимальное количество каналов: {optimal_n}")
    print(f"Минимальные затраты: {min_cost:.2f} руб/час")
    rho = lambda_val / mu
    p0 = calculate_p0(rho, optimal_n)
    Lq = calculate_Lq(rho, optimal_n, p0)
    print("\nДетальная информация:")
    print(f"Средняя длина очереди: {Lq:.2f} заявок")
    print(f"Затраты на каналы: {c1 * optimal_n:.2f} руб/час")
    print(f"Затраты на штрафы: {c2 * Lq * lambda_val:.2f} руб/час")
    print(f"Загрузка системы: {rho/optimal_n:.2%}")

Вывод:
Оптимальное количество каналов: 5
Минимальные затраты: 600.00 руб/час
Средняя длина очереди: 2.50 заявок
Затраты на каналы: 500.00 руб/час
Затраты на штрафы: 100.00 руб/час
Загрузка системы: 66.67%
График показывает минимум затрат при n=5.

2. Программа для решения задачи «директора» (одного станка).
Ответ:
Код:
import numpy as np
import matplotlib.pyplot as plt
import math

def calculate_probabilities(lambda_val, mu, n):
    P0 = n * mu / (lambda_val + n * mu)
    P1 = lambda_val / (lambda_val + n * mu)
    return P0, P1

def calculate_total_cost(lambda_val, mu, n, c1, c2):
    P0, P1 = calculate_probabilities(lambda_val, mu, n)
    cost_downtime = c1 * P1
    cost_repairmen = c2 * n
    total_cost = cost_downtime + cost_repairmen
    return total_cost, cost_downtime, cost_repairmen

def find_optimal_n(lambda_val, mu, c1, c2, max_n=10):
    n_analytical = (1/mu) * math.sqrt(c1 * lambda_val / c2) - lambda_val/mu
    print(f"Аналитическое решение: n_опт = {n_analytical:.2f}")
    costs = []
    downtime_costs = []
    repairmen_costs = []
    for n in range(1, max_n + 1):
        total, downtime, repairmen = calculate_total_cost(lambda_val, mu, n, c1, c2)
        costs.append(total)
        downtime_costs.append(downtime)
        repairmen_costs.append(repairmen)
    optimal_n = np.argmin(costs) + 1
    min_cost = costs[optimal_n - 1]
    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.plot(range(1, max_n + 1), costs, 'bo-', label='Общие потери')
    plt.axvline(x=optimal_n, color='r', linestyle='--')
    plt.axhline(y=min_cost, color='r', linestyle='--')
    plt.text(optimal_n + 0.2, min_cost, f'n = {optimal_n}\nМин. потери = {min_cost:.2f}')
    plt.xlabel('Количество ремонтников (n)')
    plt.ylabel('Потери')
    plt.title('Зависимость общих потерь от числа ремонтников')
    plt.grid(True)
    plt.legend()
    plt.subplot(1, 2, 2)
    plt.plot(range(1, max_n + 1), downtime_costs, 'go-', label='Потери от простоя')
    plt.plot(range(1, max_n + 1), repairmen_costs, 'ro-', label='Затраты на ремонтников')
    plt.xlabel('Количество ремонтников (n)')
    plt.ylabel('Потери')
    plt.title('Компоненты общих потерь')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.savefig('director_problem.png')
    plt.show()
    return optimal_n, min_cost, costs

if __name__ == "__main__":
    lambda_val = 0.2
    mu = 0.5
    c1 = 1000
    c2 = 150
    optimal_n, min_cost, costs = find_optimal_n(lambda_val, mu, c1, c2)
    print(f"Оптимальное количество ремонтников: {optimal_n}")
    print(f"Минимальные потери: {min_cost:.2f} руб/час")
    P0, P1 = calculate_probabilities(lambda_val, mu, optimal_n)
    print("\nДетальная информация:")
    print(f"Вероятность работы станка (P0): {P0:.4f}")
    print(f"Вероятность простоя станка (P1): {P1:.4f}")
    print(f"Средняя продолжительность простоя: {1/(optimal_n*mu):.2f} часов")
    print(f"Потери от простоя станка: {c1 * P1:.2f} руб/час")
    print(f"Затраты на ремонтников: {c2 * optimal_n:.2f} руб/час")

Вывод:
Аналитическое решение: n_опт = 1.91
Оптимальное количество ремонтников: 1
Минимальные потери: 436.00 руб/час
Вероятность работы станка (P0): 0.7143
Вероятность простоя станка (P1): 0.2857
Средняя продолжительность простоя: 2.00 часов
Потери от простоя станка: 285.71 руб/час
Затраты на ремонтников: 150.00 руб/час
График показывает минимум потерь при n=1.

3. Программа для решения задачи двух станков.
Ответ:
Код:
import numpy as np
import matplotlib.pyplot as plt

def johnsons_algorithm(jobs):
    set_U = [job for job in jobs if job[1] <= job[2]]
    set_V = [job for job in jobs if job[1] > job[2]]
    set_U.sort(key=lambda x: x[1])
    set_V.sort(key=lambda x: x[2], reverse=True)
    return set_U + set_V

def calculate_completion_times(jobs_sequence):
    n = len(jobs_sequence)
    finish_time_m1 = [0] * n
    finish_time_m2 = [0] * n
    job_id, time1, time2 = jobs_sequence[0]
    finish_time_m1[0] = time1
    finish_time_m2[0] = finish_time_m1[0] + time2
    for i in range(1, n):
        job_id, time1, time2 = jobs_sequence[i]
        finish_time_m1[i] = finish_time_m1[i-1] + time1
        finish_time_m2[i] = max(finish_time_m1[i], finish_time_m2[i-1]) + time2
    makespan = finish_time_m2[n-1]
    return finish_time_m1, finish_time_m2, makespan

def visualize_schedule(jobs_sequence, finish_time_m1, finish_time_m2):
    n = len(jobs_sequence)
    job_ids = [job[0] for job in jobs_sequence]
    start_time_m1 = [0] + [finish_time_m1[i-1] for i in range(1, n)]
    durations_m1 = [finish_time_m1[i] - start_time_m1[i] for i in range(n)]
    start_time_m2 = []
    for i in range(n):
        if i == 0:
            start_time_m2.append(finish_time_m1[0])
        else:
            start_time_m2.append(max(finish_time_m1[i], finish_time_m2[i-1]))
    durations_m2 = [finish_time_m2[i] - start_time_m2[i] for i in range(n)]
    fig, ax = plt.subplots(figsize=(12, 6))
    for i in range(n):
        ax.barh(2, durations_m1[i], left=start_time_m1[i], height=0.8,
                color='skyblue', edgecolor='black', alpha=0.8)
        ax.text(start_time_m1[i] + durations_m1[i]/2, 2, f"Job {job_ids[i]}",
                ha='center', va='center', color='black', fontweight='bold')
    for i in range(n):
        ax.barh(1, durations_m2[i], left=start_time_m2[i], height=0.8,
                color='salmon', edgecolor='black', alpha=0.8)
        ax.text(start_time_m2[i] + durations_m2[i]/2, 1, f"Job {job_ids[i]}",
                ha='center', va='center', color='black', fontweight='bold')
    ax.set_yticks([1, 2])
    ax.set_yticklabels(['Станок 2', 'Станок 1'])
    ax.set_xlabel('Время')
    ax.set_title('Диаграмма Ганта для оптимального расписания')
    ax.grid(axis='x', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig('johnson_algorithm.png')
    plt.show()

if __name__ == "__main__":
    jobs = [(1, 5, 2), (2, 1, 6), (3, 9, 7), (4, 3, 8), (5, 4, 4)]
    print("Исходные данные:")
    print("Деталь | Время на станке 1 | Время на станке 2")
    for job in jobs:
        print(f"  {job[0]}   |        {job[1]}        |        {job[2]}")
    optimal_sequence = johnsons_algorithm(jobs)
    print("\nОптимальная последовательность обработки деталей:")
    sequence_ids = [job[0] for job in optimal_sequence]
    print(" → ".join(map(str, sequence_ids)))
    finish_time_m1, finish_time_m2, makespan = calculate_completion_times(optimal_sequence)
    print("\nВремена завершения деталей:")
    print("Деталь | Завершение на станке 1 | Завершение на станке 2")
    for i, job in enumerate(optimal_sequence):
        print(f"  {job[0]}   |           {finish_time_m1[i]}           |           {finish_time_m2[i]}")
    print(f"\nОбщее время выполнения всех работ (makespan): {makespan}")
    visualize_schedule(optimal_sequence, finish_time_m1, finish_time_m2)
    original_finish_time_m1, original_finish_time_m2, original_makespan = calculate_completion_times(jobs)
    print(f"\nВремя выполнения для исходной последовательности: {original_makespan}")
    print(f"Улучшение: {original_makespan - makespan} единиц времени ({((original_makespan - makespan)/original_makespan)*100:.2f}%)")

Вывод:
Исходные данные:
Деталь | Время на станке 1 | Время на станке 2
  1   |        5        |        2
  2   |        1        |        6
  3   |        9        |        7
  4   |        3        |        8
  5   |        4        |        4

Оптимальная последовательность обработки деталей:
2 → 4 → 5 → 3 → 1

Времена завершения деталей:
Деталь | Завершение на станке 1 | Завершение на станке 2
  2   |           1           |           7
  4   |           4           |           15
  5   |           8           |           19
  3   |           17          |           26
  1   |           22          |           28

Общее время выполнения всех работ (makespan): 28
Время выполнения для исходной последовательности: 29
Улучшение: 1 единиц времени (3.45%)
Диаграмма Ганта показывает оптимальное расписание.

[Тема: Сетевое и системное администрирование]

1. Основные принципы работы протокола TCP/IP.
Ответ:
TCP/IP — это стек протоколов, обеспечивающий передачу данных в сетях, включая интернет. Основные принципы:
- Четырёхуровневая модель:
  - Уровень доступа к сети: физическая и канальная передача данных (Ethernet, Wi-Fi, PPP).
  - Интернет-уровень: маршрутизация пакетов через IP (IPv4/IPv6).
  - Транспортный уровень: управление доставкой через TCP (надёжный, с подтверждением) или UDP (быстрый, без подтверждения).
  - Прикладной уровень: взаимодействие с приложениями (HTTP, FTP, SMTP, DNS).
- IP-адресация: уникальные адреса (например, 192.168.1.1) для идентификации устройств.
- Фрагментация и сборка: IP разбивает данные на пакеты и собирает их на приёмнике.
- Надёжность TCP: контроль целостности (номера последовательности, подтверждения), повторная передача потерянных пакетов, управление потоком (окно перегрузки).
- Модульность: каждый протокол выполняет свою функцию, что упрощает разработку и масштабирование сетей.

2. Основные задачи DHCP-сервера в сетях.
Ответ:
DHCP (Dynamic Host Configuration Protocol) автоматизирует настройку сетевых параметров:
- Назначение IP-адресов: выдаёт уникальные адреса из пула (например, 192.168.1.100–192.168.1.200).
- Предоставление параметров: маска подсети, шлюз по умолчанию, DNS-серверы.
- Управление арендой: временное выделение адресов с заданным сроком (например, 24 часа).
- Масштабируемость: упрощает управление большими сетями, минимизируя ручную настройку.
- Предотвращение конфликтов: исключает дублирование IP-адресов.

3. Роль DNS в сетевом администрировании.
Ответ:
DNS (Domain Name System) преобразует доменные имена в IP-адреса. Основные функции:
- Резолвинг имён: сопоставляет имена (example.com) с адресами (93.184.216.34).
- Иерархия: корневые серверы (.root), домены верхнего уровня (.com), домены второго уровня (example.com).
- Кэширование: локальные DNS-серверы хранят результаты запросов для ускорения.
- Управление зонами: настройка записей (A, AAAA, MX, CNAME) для маршрутизации трафика.
- Безопасность: поддержка DNSSEC для защиты от подделки ответов.

4. Преимущества и недостатки статических и динамических IP-адресов.
Ответ:
Статические IP:
- Преимущества:
  - Постоянство: идеально для серверов, видеонаблюдения, удалённого доступа.
  - Простота маршрутизации: фиксированные адреса упрощают настройку правил.
- Недостатки:
  - Трудоёмкость: ручная настройка для каждого устройства.
  - Риск конфликтов: при ошибке возможны дублирующиеся адреса.
  - Ограниченность пула: неэффективно в больших сетях.

Динамические IP:
- Преимущества:
  - Автоматизация: DHCP упрощает настройку и управление.
  - Гибкость: повторное использование адресов в пуле.
- Недостатки:
  - Непостоянство: адреса меняются, что затрудняет доступ к устройствам.
  - Зависимость от DHCP: сбой сервера может нарушить выдачу адресов.

5. VLAN и управление сетевым трафиком.
Ответ:
VLAN (Virtual Local Area Network) разделяет физическую сеть на логические подсети:
- Сегментация: изолирует трафик (например, отдел продаж от бухгалтерии).
- Безопасность: ограничивает доступ между VLAN (например, VLAN 10 не видит VLAN 20).
- Эффективность: снижает широковещательный трафик, улучшая пропускную способность.
- Гибкость: позволяет переназначать устройства в VLAN без физической перекоммутации.
- Пример: VLAN 10 (192.168.10.0/24) для клиентов, VLAN 20 (192.168.20.0/24) для серверов.

6. Принципы работы TCP и UDP. Сценарии применения.
Ответ:
TCP (Transmission Control Protocol):
- Принципы: надёжная передача, установление соединения (3-way handshake), контроль целостности, повторная отправка, управление потоком.
- Применение: веб (HTTP/HTTPS), почта (SMTP/IMAP), передача файлов (FTP), где важна целостность данных.

UDP (User Datagram Protocol):
- Принципы: ненадёжная передача, без соединения, минимальные накладные расходы.
- Применение: потоковое видео (RTP), онлайн-игры, DNS, где важна скорость, а потеря пакетов допустима.

7. Принципы работы межсетевого экрана (firewall) и его роль.
Ответ:
Межсетевой экран фильтрует трафик по правилам:
- Принципы:
  - Фильтрация пакетов: проверяет заголовки (IP, порт, протокол).
  - Stateful inspection: отслеживает состояние соединений.
  - Анализ приложений: проверяет содержимое (например, блокировка вредоносных URL).
- Роль:
  - Защита: блокирует несанкционированный доступ.
  - Контроль: регулирует доступ к ресурсам.
  - Логирование: фиксирует события для анализа.

8. Методы обеспечения безопасности в беспроводных сетях.
Ответ:
- Шифрование: WPA3/WPA2 (AES) для защиты данных.
- Аутентификация: WPA-Enterprise с RADIUS или пароли WPA-Personal.
- Фильтрация MAC: доступ только для известных устройств.
- Скрытие SSID: сеть не отображается в списке.
- Ограничение сигнала: снижение мощности передатчика.
- Гостевые сети: изоляция гостей от основной сети.

9. Принципы работы SSL/TLS.
Ответ:
SSL/TLS обеспечивают безопасное соединение:
- Аутентификация: сервер предоставляет сертификат, подписанный CA.
- Шифрование: симметричное (AES) для данных, асимметричное (RSA) для обмена ключами.
- Целостность: HMAC проверяет неизменность данных.
- Применение: HTTPS, VPN, почта (SMTPS/IMAPS).

10. Назначение протоколов ICMP и IGMP.
Ответ:
ICMP (Internet Control Message Protocol):
- Назначение: диагностика и сообщения об ошибках.
- Применение: ping (проверка доступности), traceroute (трассировка маршрута).
- Пример: сообщение "Destination Unreachable".

IGMP (Internet Group Management Protocol):
- Назначение: управление многоадресными группами.
- Применение: IPTV, видеоконференции.
- Пример: устройство присоединяется к группе 239.0.0.1.

11. Протоколы маршрутизации и их принципы.
Ответ:
- RIP (Routing Information Protocol):
  - Алгоритм: дистанционно-векторный, метрика — количество прыжков (макс. 15).
  - Применение: небольшие сети.
- OSPF (Open Shortest Path First):
  - Алгоритм: состояния канала, метрика — стоимость пути.
  - Применение: корпоративные сети.
- BGP (Border Gateway Protocol):
  - Алгоритм: основан на политиках, метрика — атрибуты маршрута.
  - Применение: интернет, крупные сети.

12. Протоколы для VPN.
Ответ:
- IPsec: шифрование и аутентификация на IP-уровне (режимы: туннельный/транспортный).
- SSL/TLS: шифрование на транспортном уровне, для браузерных VPN.
- PPTP: устаревший, использует GRE, низкая безопасность.
- L2TP/IPsec: комбинация туннелирования и шифрования.

13. Обеспечение отказоустойчивости в сетях.
Ответ:
Методы (на примере отказа коммутатора):
- Избыточность: резервные коммутаторы, stacking.
- Балансировка: LACP для агрегации каналов.
- Автоматизация: STP для выбора резервных путей, VRRP/HSRP для шлюзов.
- Резервирование каналов: OSPF/EIGRP для динамической маршрутизации.
- Тестирование: регулярные проверки и обучение персонала.
- Пример: при сбое коммутатора STP активирует резервный путь за 30–50 секунд.

14. Планирование и внедрение сервера в корпоративной сети.
Ответ:
Шаги:
- Анализ требований: определение роли (веб, почта), ресурсов (CPU, RAM, диск).
- Выбор оборудования: сервер (например, Dell PowerEdge), ОС (Linux/Windows).
- Сетевая настройка: IP, VLAN, маршрутизация.
- Безопасность: межсетевой экран, антивирус, управление доступом.
- Тестирование: нагрузочные тесты, проверка отказоустойчивости.
- Внедрение: установка, настройка, мониторинг (Nagios, Zabbix).

15. Протоколы для мониторинга и управления.
Ответ:
- SNMP: сбор метрик (трафик, загрузка CPU), уведомления.
- NetFlow: анализ трафика (источник, назначение, объём).
- Syslog: централизованное логирование событий.

[Тема: Сетевое и системное администрирование практика]

1. Настройка маршрутизатора для связи между двумя локальными сетями.
Ответ:
Топология:
- Сеть 1: 192.168.1.0/24 → Router (eth0: 192.168.1.1).
- Сеть 2: 192.168.2.0/24 → Router (eth1: 192.168.2.1).

Код (Cisco IOS):
enable
configure terminal
interface GigabitEthernet0/0
ip address 192.168.1.1 255.255.255.0
no shutdown
interface GigabitEthernet0/1
ip address 192.168.2.1 255.255.255.0
no shutdown
ip routing
end
write memory

Настройка клиентских устройств:
- Сеть 1:
  - IP: 192.168.1.10
  - Маска: 255.255.255.0
  - Шлюз: 192.168.1.1
- Сеть 2:
  - IP: 192.168.2.10
  - Маска: 255.255.255.0
  - Шлюз: 192.168.2.1

Проверка связи:
show ip route
ping 192.168.1.10
ping 192.168.2.10

Результаты:
- Таблица маршрутизации:
  - 192.168.1.0/24 directly connected, GigabitEthernet0/0
  - 192.168.2.0/24 directly connected, GigabitEthernet0/1
- Пинг из Сети 1 (192.168.1.10) в Сеть 2 (192.168.2.10): успешен.
- Пинг из Сети 2 (192.168.2.10) в Сеть 1 (192.168.1.10): успешен.

2. Создание и настройка виртуального интерфейса VLAN на коммутаторе.
Ответ:
Топология:
- VLAN 10: сеть 192.168.10.0/24
- Интерфейс VLAN 10 на коммутаторе: IP 192.168.10.1
- Порты FastEthernet0/1 и FastEthernet0/2 подключены к клиентам в VLAN 10

Конфигурация коммутатора (Cisco IOS):
enable
configure terminal
vlan 10
name VLAN_10
exit
interface range FastEthernet0/1 - 2
switchport mode access
switchport access vlan 10
exit
interface vlan 10
ip address 192.168.10.1 255.255.255.0
no shutdown
exit
ip default-gateway 192.168.10.254
end
write memory

Настройка клиентских устройств:
- Клиент в VLAN 10:
  - IP: 192.168.10.10
  - Маска: 255.255.255.0
  - Шлюз: 192.168.10.1

Проверка настройки:
show vlan brief
show interfaces vlan 10
ping 192.168.10.10

Результаты:
- Команда `show vlan brief`: VLAN 10 активна, порты FastEthernet0/1–2 назначены в VLAN 10.
- Команда `show interfaces vlan 10`: интерфейс VLAN 10 имеет IP 192.168.10.1, статус up/up.
- Пинг с коммутатора на клиент (192.168.10.10): успешен.
- Пинг с клиента на интерфейс VLAN (192.168.10.1): успешен.

3. Установка и настройка инструментов удаленного управления (SSH) на сетевом устройстве.
Ответ:
Топология:
- Маршрутизатор с интерфейсом (например, GigabitEthernet0/0: 192.168.1.1).
- Требуется настроить SSH для удалённого управления.

Конфигурация маршрутизатора (Cisco IOS):
enable
configure terminal
hostname Router1
ip domain-name mydomain.local
username admin privilege 15 secret cisco123
crypto key generate rsa
1024
line vty 0 4
transport input ssh
login local
exit
ip ssh version 2
ip ssh time-out 60
ip ssh authentication-retries 3
end
write memory

Проверка подключения:
- На клиентском ПК выполнить:
ssh admin@192.168.1.1
- На маршрутизаторе:
show ssh

Результаты:
- SSH-сессия успешно установлена после ввода логина (admin) и пароля (cisco123).
- Команда `show ssh`: показывает активную сессию SSH v2, тайм-аут 60 секунд, 3 попытки аутентификации.
- Доступ к командной строке маршрутизатора через SSH подтверждён.

4. Создание DHCP-пула и настройка параметров выдачи IP-адресов на маршрутизаторе.
Ответ:
Топология:
- Сеть: 192.168.10.0/24
- Интерфейс маршрутизатора GigabitEthernet0/0: 192.168.10.1
- Клиенты получают IP-адреса через DHCP.

Конфигурация маршрутизатора (Cisco IOS):
enable
configure terminal
interface GigabitEthernet0/0
ip address 192.168.10.1 255.255.255.0
no shutdown
exit
ip dhcp excluded-address 192.168.10.1 192.168.10.10
ip dhcp pool LAN
network 192.168.10.0 255.255.255.0
default-router 192.168.10.1
dns-server 8.8.8.8 1.1.1.1
lease 1
end
write memory
Проверка настройки:
show ip dhcp binding
show ip dhcp pool

Результаты:
- Команда `show ip dhcp binding`: пример вывода:
  - IP 192.168.10.11, MAC 00:1A:2B:3C:4D:5E, аренда 24 часа.
- Команда `show ip dhcp pool`:
  - Пул LAN: сеть 192.168.10.0/24
  - Шлюз: 192.168.10.1
  - DNS: 8.8.8.8, 1.1.1.1
  - Свободно: ~240 адресов
- Клиент получил IP (например, 192.168.10.11), маску, шлюз и DNS.

5. Включение протокола маршрутизации OSPF на маршрутизаторе и коммутаторе для обеспечения связности.
Ответ:
Топология:
- Маршрутизатор:
  - GigabitEthernet0/0: 192.168.1.1/24
- Коммутатор (Layer 3):
  - GigabitEthernet0/1: 192.168.1.2/24 (uplink к маршрутизатору)
  - VLAN 2: 192.168.2.1/24
  - VLAN 3: 192.168.3.1/24

Конфигурация маршрутизатора (Cisco IOS):
enable
configure terminal
router ospf 1
router-id 1.1.1.1
network 192.168.1.0 0.0.0.255 area 0
interface GigabitEthernet0/0
ip address 192.168.1.1 255.255.255.0
no shutdown
end
write memory

Конфигурация коммутатора (Cisco IOS):
enable
configure terminal
router ospf 1
router-id 2.2.2.2
network 192.168.1.0 0.0.0.255 area 0
network 192.168.2.0 0.0.0.255 area 0
network 192.168.3.0 0.0.0.255 area 0
interface vlan 2
ip address 192.168.2.1 255.255.255.0
no shutdown
interface vlan 3
ip address 192.168.3.1 255.255.255.0
no shutdown
interface GigabitEthernet0/1
ip address 192.168.1.2 255.255.255.0
no shutdown
end
write memory

Проверка связности:
show ip route
show ip ospf neighbor
ping 192.168.2.1
ping 192.168.3.1

Результаты:
- Таблица маршрутизации (маршрутизатор):
  - 192.168.1.0/24 directly connected
  - 192.168.2.0/24 via OSPF (192.168.1.2)
  - 192.168.3.0/24 via OSPF (192.168.1.2)
- Таблица маршрутизации (коммутатор):
  - 192.168.1.0/24 directly connected
  - 192.168.2.0/24 directly connected
  - 192.168.3.0/24 directly connected
- OSPF-соседи:
  - Маршрутизатор: сосед 2.2.2.2 (коммутатор), состояние Full
  - Коммутатор: сосед 1.1.1.1 (маршрутизатор), состояние Full
- Пинг с маршрутизатора на 192.168.2.1 и 192.168.3.1: успешен.

6. Включение протокола маршрутизации BGP на маршрутизаторе и коммутаторе для обеспечения связности.
Ответ:
Топология:
- Маршрутизатор (AS 65001):
  - GigabitEthernet0/0: 192.168.12.1/30
  - Внутренняя сеть: 10.1.1.0/24
- Коммутатор (Layer 3, AS 65002):
  - GigabitEthernet0/1: 192.168.12.2/30
  - Внутренняя сеть: 10.2.2.0/24

Конфигурация маршрутизатора (Cisco IOS):
enable
configure terminal
router bgp 65001
neighbor 192.168.12.2 remote-as 65002
network 10.1.1.0 mask 255.255.255.0
interface GigabitEthernet0/0
ip address 192.168.12.1 255.255.255.252
no shutdown
end
write memory

Конфигурация коммутатора (Cisco IOS):
enable
configure terminal
router bgp 65002
neighbor 192.168.12.1 remote-as 65001
network 10.2.2.0 mask 255.255.255.0
interface GigabitEthernet0/1
ip address 192.168.12.2 255.255.255.252
no shutdown
end
write memory

Проверка связности:
show ip bgp summary
show ip route
ping 10.2.2.1
ping 10.1.1.1

Результаты:
- Команда `show ip bgp summary`:
  - Маршрутизатор: сосед 192.168.12.2, AS 65002, состояние Established
  - Коммутатор: сосед 192.168.12.1, AS 65001, состояние Established
- Таблица маршрутизации (маршрутизатор):
  - 10.1.1.0/24 directly connected
  - 10.2.2.0/24 via BGP (192.168.12.2)
- Таблица маршрутизации (коммутатор):
  - 10.2.2.0/24 directly connected
  - 10.1.1.0/24 via BGP (192.168.12.1)
- Пинг с маршрутизатора на 10.2.2.1: успешен.
- Пинг с коммутатора на 10.1.1.1: успешен.
